from _typeshed import Incomplete
from sympy.core.expr import Expr as Expr
from sympy.core.logic import fuzzy_not as fuzzy_not, fuzzy_or as fuzzy_or
from sympy.core.numbers import Rational as Rational
from sympy.core.relational import is_eq as is_eq
from sympy.core.singleton import S as S
from sympy.core.sympify import sympify as sympify
from sympy.functions.elementary.complexes import conjugate as conjugate, im as im, re as re, sign as sign
from sympy.functions.elementary.exponential import exp as exp
from sympy.functions.elementary.miscellaneous import sqrt as sqrt
from sympy.functions.elementary.trigonometric import acos as acos, asin as asin, atan2 as atan2, cos as cos, sin as sin
from sympy.integrals.integrals import integrate as integrate
from sympy.simplify.trigsimp import trigsimp as trigsimp
from sympy.utilities.misc import as_int as as_int

class Quaternion(Expr):
    is_commutative: bool
    def __new__(cls, a: int = 0, b: int = 0, c: int = 0, d: int = 0, real_field: bool = True, norm: Incomplete | None = None): ...
    def set_norm(self, norm) -> None: ...
    @property
    def a(self): ...
    @property
    def b(self): ...
    @property
    def c(self): ...
    @property
    def d(self): ...
    @property
    def real_field(self): ...
    @property
    def product_matrix_left(self): ...
    @property
    def product_matrix_right(self): ...
    def to_Matrix(self, vector_only: bool = False): ...
    @classmethod
    def from_Matrix(cls, elements): ...
    @classmethod
    def from_euler(cls, angles, seq): ...
    def to_euler(self, seq, angle_addition: bool = True, avoid_square_root: bool = False): ...
    @classmethod
    def from_axis_angle(cls, vector, angle): ...
    @classmethod
    def from_rotation_matrix(cls, M): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __pow__(self, p): ...
    def __neg__(self): ...
    def __truediv__(self, other): ...
    def __rtruediv__(self, other): ...
    def diff(self, *symbols, **kwargs): ...
    def add(self, other): ...
    def mul(self, other): ...
    def norm(self): ...
    def normalize(self): ...
    def inverse(self): ...
    def pow(self, p): ...
    def exp(self): ...
    def log(self): ...
    def pow_cos_sin(self, p): ...
    def integrate(self, *args): ...
    @staticmethod
    def rotate_point(pin, r): ...
    def to_axis_angle(self): ...
    def to_rotation_matrix(self, v: Incomplete | None = None, homogeneous: bool = True): ...
    def scalar_part(self): ...
    def vector_part(self): ...
    def axis(self): ...
    def is_pure(self): ...
    def is_zero_quaternion(self): ...
    def angle(self): ...
    def arc_coplanar(self, other): ...
    @classmethod
    def vector_coplanar(cls, q1, q2, q3): ...
    def parallel(self, other): ...
    def orthogonal(self, other): ...
    def index_vector(self): ...
    def mensor(self): ...
