from .conflict import AmbiguityWarning as AmbiguityWarning, ambiguities as ambiguities, ordering as ordering, super_signature as super_signature
from .utils import expand_tuples as expand_tuples
from _typeshed import Incomplete
from collections.abc import Generator

class MDNotImplementedError(NotImplementedError): ...

def ambiguity_warn(dispatcher, ambiguities) -> None: ...

class RaiseNotImplementedError:
    dispatcher: Incomplete
    def __init__(self, dispatcher) -> None: ...
    def __call__(self, *args, **kwargs) -> None: ...

def ambiguity_register_error_ignore_dup(dispatcher, ambiguities) -> None: ...
def halt_ordering() -> None: ...
def restart_ordering(on_ambiguity=...) -> None: ...

class Dispatcher:
    name: Incomplete
    funcs: Incomplete
    ordering: Incomplete
    doc: Incomplete
    def __init__(self, name, doc: Incomplete | None = None) -> None: ...
    def register(self, *types, **kwargs): ...
    @classmethod
    def get_func_params(cls, func): ...
    @classmethod
    def get_func_annotations(cls, func): ...
    def add(self, signature, func, on_ambiguity=...) -> None: ...
    def reorder(self, on_ambiguity=...) -> None: ...
    def __call__(self, *args, **kwargs): ...
    def dispatch(self, *types): ...
    def dispatch_iter(self, *types) -> Generator[Incomplete]: ...
    def resolve(self, types): ...
    @property
    def __doc__(self): ...
    def help(self, *args, **kwargs) -> None: ...
    def source(self, *args, **kwargs) -> None: ...

def source(func): ...

class MethodDispatcher(Dispatcher):
    @classmethod
    def get_func_params(cls, func): ...
    obj: Incomplete
    cls: Incomplete
    def __get__(self, instance, owner): ...
    def __call__(self, *args, **kwargs): ...

def str_signature(sig): ...
def warning_text(name, amb): ...
