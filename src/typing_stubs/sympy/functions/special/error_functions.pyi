from sympy.core import EulerGamma as EulerGamma
from sympy.core.add import Add as Add
from sympy.core.cache import cacheit as cacheit
from sympy.core.function import ArgumentIndexError as ArgumentIndexError, Function as Function, expand_mul as expand_mul
from sympy.core.numbers import I as I, Rational as Rational, pi as pi
from sympy.core.power import Pow as Pow
from sympy.core.relational import is_eq as is_eq
from sympy.core.singleton import S as S
from sympy.core.symbol import Dummy as Dummy, uniquely_named_symbol as uniquely_named_symbol
from sympy.core.sympify import sympify as sympify
from sympy.functions.combinatorial.factorials import RisingFactorial as RisingFactorial, factorial as factorial, factorial2 as factorial2
from sympy.functions.elementary.complexes import polar_lift as polar_lift, re as re, unpolarify as unpolarify
from sympy.functions.elementary.exponential import exp as exp, exp_polar as exp_polar, log as log
from sympy.functions.elementary.hyperbolic import cosh as cosh, sinh as sinh
from sympy.functions.elementary.integers import ceiling as ceiling, floor as floor
from sympy.functions.elementary.miscellaneous import root as root, sqrt as sqrt
from sympy.functions.elementary.trigonometric import cos as cos, sin as sin, sinc as sinc
from sympy.functions.special.hyper import hyper as hyper, meijerg as meijerg

def real_to_real_as_real_imag(self, deep: bool = True, **hints): ...

class erf(Function):
    unbranched: bool
    def fdiff(self, argindex: int = 1): ...
    def inverse(self, argindex: int = 1): ...
    @classmethod
    def eval(cls, arg): ...
    @staticmethod
    def taylor_term(n, x, *previous_terms): ...
    as_real_imag = real_to_real_as_real_imag

class erfc(Function):
    unbranched: bool
    def fdiff(self, argindex: int = 1): ...
    def inverse(self, argindex: int = 1): ...
    @classmethod
    def eval(cls, arg): ...
    @staticmethod
    def taylor_term(n, x, *previous_terms): ...
    as_real_imag = real_to_real_as_real_imag

class erfi(Function):
    unbranched: bool
    def fdiff(self, argindex: int = 1): ...
    @classmethod
    def eval(cls, z): ...
    @staticmethod
    def taylor_term(n, x, *previous_terms): ...
    as_real_imag = real_to_real_as_real_imag

class erf2(Function):
    def fdiff(self, argindex): ...
    @classmethod
    def eval(cls, x, y): ...

class erfinv(Function):
    def fdiff(self, argindex: int = 1): ...
    def inverse(self, argindex: int = 1): ...
    @classmethod
    def eval(cls, z): ...

class erfcinv(Function):
    def fdiff(self, argindex: int = 1): ...
    def inverse(self, argindex: int = 1): ...
    @classmethod
    def eval(cls, z): ...

class erf2inv(Function):
    def fdiff(self, argindex): ...
    @classmethod
    def eval(cls, x, y): ...

class Ei(Function):
    @classmethod
    def eval(cls, z): ...
    def fdiff(self, argindex: int = 1): ...

class expint(Function):
    @classmethod
    def eval(cls, nu, z): ...
    def fdiff(self, argindex): ...

def E1(z): ...

class li(Function):
    @classmethod
    def eval(cls, z): ...
    def fdiff(self, argindex: int = 1): ...

class Li(Function):
    @classmethod
    def eval(cls, z): ...
    def fdiff(self, argindex: int = 1): ...

class TrigonometricIntegral(Function):
    @classmethod
    def eval(cls, z): ...
    def fdiff(self, argindex: int = 1): ...

class Si(TrigonometricIntegral): ...
class Ci(TrigonometricIntegral): ...
class Shi(TrigonometricIntegral): ...
class Chi(TrigonometricIntegral): ...

class FresnelIntegral(Function):
    unbranched: bool
    @classmethod
    def eval(cls, z): ...
    def fdiff(self, argindex: int = 1): ...
    as_real_imag = real_to_real_as_real_imag

class fresnels(FresnelIntegral):
    @staticmethod
    def taylor_term(n, x, *previous_terms): ...

class fresnelc(FresnelIntegral):
    @staticmethod
    def taylor_term(n, x, *previous_terms): ...

class _erfs(Function):
    @classmethod
    def eval(cls, arg): ...
    def fdiff(self, argindex: int = 1): ...

class _eis(Function):
    def fdiff(self, argindex: int = 1): ...
