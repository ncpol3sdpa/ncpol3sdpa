from _typeshed import Incomplete
from sympy.core.add import Add as Add
from sympy.core.cache import cacheit as cacheit
from sympy.core.expr import Expr as Expr
from sympy.core.function import ArgumentIndexError as ArgumentIndexError, Function as Function, FunctionClass as FunctionClass, PoleError as PoleError, expand_complex as expand_complex, expand_log as expand_log, expand_mul as expand_mul, expand_multinomial as expand_multinomial
from sympy.core.logic import fuzzy_and as fuzzy_and, fuzzy_not as fuzzy_not, fuzzy_or as fuzzy_or
from sympy.core.mul import Mul as Mul
from sympy.core.numbers import I as I, Integer as Integer, Rational as Rational, pi as pi
from sympy.core.parameters import global_parameters as global_parameters
from sympy.core.power import Pow as Pow
from sympy.core.singleton import S as S
from sympy.core.symbol import Dummy as Dummy, Wild as Wild
from sympy.core.sympify import sympify as sympify
from sympy.functions.combinatorial.factorials import factorial as factorial
from sympy.functions.elementary.complexes import Abs as Abs, arg as arg, im as im, re as re, unpolarify as unpolarify
from sympy.functions.elementary.miscellaneous import sqrt as sqrt
from sympy.ntheory import multiplicity as multiplicity, perfect_power as perfect_power
from sympy.ntheory.factor_ import factorint as factorint

class ExpBase(Function):
    unbranched: bool
    @property
    def kind(self): ...
    def inverse(self, argindex: int = 1): ...
    def as_numer_denom(self): ...
    @property
    def exp(self): ...
    def as_base_exp(self): ...

class exp_polar(ExpBase):
    is_polar: bool
    is_comparable: bool
    def as_base_exp(self): ...

class ExpMeta(FunctionClass):
    def __instancecheck__(cls, instance): ...

class exp(ExpBase, metaclass=ExpMeta):
    def fdiff(self, argindex: int = 1): ...
    @classmethod
    def eval(cls, arg): ...
    @property
    def base(self): ...
    @staticmethod
    def taylor_term(n, x, *previous_terms): ...
    def as_real_imag(self, deep: bool = True, **hints): ...

def match_real_imag(expr): ...

class log(Function):
    args: tuple[Expr]
    def fdiff(self, argindex: int = 1): ...
    def inverse(self, argindex: int = 1): ...
    @classmethod
    def eval(cls, arg, base: Incomplete | None = None): ...
    def as_base_exp(self): ...
    @staticmethod
    def taylor_term(n, x, *previous_terms): ...
    def as_real_imag(self, deep: bool = True, **hints): ...

class LambertW(Function):
    @classmethod
    def eval(cls, x, k: Incomplete | None = None): ...
    def fdiff(self, argindex: int = 1): ...
