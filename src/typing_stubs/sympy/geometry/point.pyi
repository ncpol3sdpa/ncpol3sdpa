from .entity import GeometryEntity as GeometryEntity
from _typeshed import Incomplete
from sympy.core import Expr as Expr, S as S, sympify as sympify
from sympy.core.add import Add as Add
from sympy.core.containers import Tuple as Tuple
from sympy.core.numbers import Float as Float
from sympy.core.parameters import global_parameters as global_parameters
from sympy.functions.elementary.complexes import im as im
from sympy.functions.elementary.miscellaneous import sqrt as sqrt
from sympy.functions.elementary.trigonometric import cos as cos, sin as sin
from sympy.geometry.exceptions import GeometryError as GeometryError
from sympy.matrices import Matrix as Matrix
from sympy.matrices.expressions import Transpose as Transpose
from sympy.simplify import nsimplify as nsimplify, simplify as simplify
from sympy.utilities.iterables import is_sequence as is_sequence, uniq as uniq
from sympy.utilities.misc import Undecidable as Undecidable, filldedent as filldedent, func_name as func_name

class Point(GeometryEntity):
    is_Point: bool
    def __new__(cls, *args, **kwargs): ...
    def __abs__(self): ...
    def __add__(self, other): ...
    def __contains__(self, item) -> bool: ...
    def __truediv__(self, divisor): ...
    def __eq__(self, other): ...
    def __getitem__(self, key): ...
    def __hash__(self): ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __mul__(self, factor): ...
    def __rmul__(self, factor): ...
    def __neg__(self): ...
    def __sub__(self, other): ...
    @staticmethod
    def affine_rank(*args): ...
    @property
    def ambient_dimension(self): ...
    @classmethod
    def are_coplanar(cls, *points): ...
    def distance(self, other): ...
    def dot(self, p): ...
    def equals(self, other): ...
    def intersection(self, other): ...
    def is_collinear(self, *args): ...
    def is_concyclic(self, *args): ...
    @property
    def is_nonzero(self): ...
    def is_scalar_multiple(self, p): ...
    @property
    def is_zero(self): ...
    @property
    def length(self): ...
    def midpoint(self, p): ...
    @property
    def origin(self): ...
    @property
    def orthogonal_direction(self): ...
    @staticmethod
    def project(a, b): ...
    def taxicab_distance(self, p): ...
    def canberra_distance(self, p): ...
    @property
    def unit(self): ...

class Point2D(Point):
    def __new__(cls, *args, _nocheck: bool = False, **kwargs): ...
    def __contains__(self, item) -> bool: ...
    @property
    def bounds(self): ...
    def rotate(self, angle, pt: Incomplete | None = None): ...
    def scale(self, x: int = 1, y: int = 1, pt: Incomplete | None = None): ...
    def transform(self, matrix): ...
    def translate(self, x: int = 0, y: int = 0): ...
    @property
    def coordinates(self): ...
    @property
    def x(self): ...
    @property
    def y(self): ...

class Point3D(Point):
    def __new__(cls, *args, _nocheck: bool = False, **kwargs): ...
    def __contains__(self, item) -> bool: ...
    @staticmethod
    def are_collinear(*points): ...
    def direction_cosine(self, point): ...
    def direction_ratio(self, point): ...
    def intersection(self, other): ...
    def scale(self, x: int = 1, y: int = 1, z: int = 1, pt: Incomplete | None = None): ...
    def transform(self, matrix): ...
    def translate(self, x: int = 0, y: int = 0, z: int = 0): ...
    @property
    def coordinates(self): ...
    @property
    def x(self): ...
    @property
    def y(self): ...
    @property
    def z(self): ...
