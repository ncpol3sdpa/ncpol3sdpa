from .integrals import Integral as Integral, integrate as integrate
from _typeshed import Incomplete
from sympy.core.function import Lambda as Lambda
from sympy.core.intfunc import ilcm as ilcm
from sympy.core.mul import Mul as Mul
from sympy.core.numbers import I as I
from sympy.core.power import Pow as Pow
from sympy.core.relational import Ne as Ne
from sympy.core.singleton import S as S
from sympy.core.sorting import default_sort_key as default_sort_key, ordered as ordered
from sympy.core.symbol import Dummy as Dummy, Symbol as Symbol
from sympy.functions.elementary.exponential import exp as exp, log as log
from sympy.functions.elementary.hyperbolic import cosh as cosh, coth as coth, sinh as sinh, tanh as tanh
from sympy.functions.elementary.piecewise import Piecewise as Piecewise
from sympy.functions.elementary.trigonometric import acos as acos, acot as acot, asin as asin, atan as atan, cos as cos, cot as cot, sin as sin, tan as tan
from sympy.polys.polyerrors import PolynomialError as PolynomialError
from sympy.polys.polytools import Poly as Poly, cancel as cancel, gcd as gcd, real_roots as real_roots, reduced as reduced
from sympy.polys.rootoftools import RootSum as RootSum
from sympy.utilities.iterables import numbered_symbols as numbered_symbols

def integer_powers(exprs): ...

class DifferentialExtension:
    f: Incomplete
    x: Incomplete
    dummy: Incomplete
    newf: Incomplete
    def __init__(self, f: Incomplete | None = None, x: Incomplete | None = None, handle_first: str = 'log', dummy: bool = False, extension: Incomplete | None = None, rewrite_complex: Incomplete | None = None) -> None: ...
    def __getattr__(self, attr) -> None: ...
    def __eq__(self, other): ...
    t: Incomplete
    T: Incomplete
    D: Incomplete
    level: int
    exts: Incomplete
    extargs: Incomplete
    ts: Incomplete
    backsubs: Incomplete
    Tfuncs: Incomplete
    def reset(self) -> None: ...
    def indices(self, extension): ...
    d: Incomplete
    case: Incomplete
    def increment_level(self) -> None: ...
    def decrement_level(self) -> None: ...

def update_sets(seq, atoms, func): ...

class DecrementLevel:
    DE: Incomplete
    def __init__(self, DE) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...

class NonElementaryIntegralException(Exception): ...

def gcdex_diophantine(a, b, c): ...
def frac_in(f, t, *, cancel: bool = False, **kwargs): ...
def as_poly_1t(p, t, z): ...
def derivation(p, DE, coefficientD: bool = False, basic: bool = False): ...
def get_case(d, t): ...
def splitfactor(p, DE, coefficientD: bool = False, z: Incomplete | None = None): ...
def splitfactor_sqf(p, DE, coefficientD: bool = False, z: Incomplete | None = None, basic: bool = False): ...
def canonical_representation(a, d, DE): ...
def hermite_reduce(a, d, DE): ...
def polynomial_reduce(p, DE): ...
def laurent_series(a, d, F, n, DE): ...
def recognize_derivative(a, d, DE, z: Incomplete | None = None): ...
def recognize_log_derivative(a, d, DE, z: Incomplete | None = None): ...
def residue_reduce(a, d, DE, z: Incomplete | None = None, invert: bool = True): ...
def residue_reduce_to_basic(H, DE, z): ...
def residue_reduce_derivation(H, DE, z): ...
def integrate_primitive_polynomial(p, DE): ...
def integrate_primitive(a, d, DE, z: Incomplete | None = None): ...
def integrate_hyperexponential_polynomial(p, DE, z): ...
def integrate_hyperexponential(a, d, DE, z: Incomplete | None = None, conds: str = 'piecewise'): ...
def integrate_hypertangent_polynomial(p, DE): ...
def integrate_nonlinear_no_specials(a, d, DE, z: Incomplete | None = None): ...

class NonElementaryIntegral(Integral): ...

def risch_integrate(f, x, extension: Incomplete | None = None, handle_first: str = 'log', separate_integral: bool = False, rewrite_complex: Incomplete | None = None, conds: str = 'piecewise'): ...
