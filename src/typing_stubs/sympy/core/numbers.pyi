from .add import Add as Add
from .basic import Basic as Basic
from .cache import cacheit as cacheit, clear_cache as clear_cache
from .containers import Tuple as Tuple
from .evalf import pure_complex as pure_complex
from .expr import AtomicExpr as AtomicExpr, Expr as Expr
from .intfunc import igcd as igcd, ilcm as ilcm, integer_nthroot as integer_nthroot, mod_inverse as mod_inverse, num_digits as num_digits
from .kind import NumberKind as NumberKind
from .logic import fuzzy_not as fuzzy_not
from .mul import Mul as Mul
from .parameters import global_parameters as global_parameters
from .power import Pow as Pow
from .singleton import S as S, Singleton as Singleton
from .sympify import SympifyError as SympifyError, sympify as sympify
from _typeshed import Incomplete
from sympy.external.gmpy import SYMPY_INTS as SYMPY_INTS, flint as flint, gmpy as gmpy
from sympy.multipledispatch import dispatch as dispatch
from sympy.utilities.misc import debug as debug

def comp(z1, z2, tol: Incomplete | None = None): ...
def mpf_norm(mpf, prec): ...
def seterr(divide: bool = False) -> None: ...

class Number(AtomicExpr):
    is_commutative: bool
    is_number: bool
    is_Number: bool
    kind = NumberKind
    def __new__(cls, *obj): ...
    def could_extract_minus_sign(self): ...
    def invert(self, other, *gens, **args): ...
    def __divmod__(self, other): ...
    def __rdivmod__(self, other): ...
    def __float__(self) -> float: ...
    def floor(self) -> None: ...
    def ceiling(self) -> None: ...
    def __floor__(self) -> int: ...
    def __ceil__(self) -> int: ...
    @classmethod
    def class_key(cls): ...
    def sort_key(self, order: Incomplete | None = None): ...
    def __add__(self, other): ...
    def __sub__(self, other): ...
    def __mul__(self, other): ...
    def __truediv__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __hash__(self): ...
    def is_constant(self, *wrt, **flags): ...
    def as_coeff_mul(self, *deps, rational: bool = True, **kwargs): ...
    def as_coeff_add(self, *deps): ...
    def as_coeff_Mul(self, rational: bool = False): ...
    def as_coeff_Add(self, rational: bool = False): ...
    def gcd(self, other): ...
    def lcm(self, other): ...
    def cofactors(self, other): ...

class Float(Number):
    is_rational: Incomplete
    is_irrational: Incomplete
    is_number: bool
    is_real: bool
    is_extended_real: bool
    is_Float: bool
    def __new__(cls, num, dps: Incomplete | None = None, precision: Incomplete | None = None): ...
    def __getnewargs_ex__(self): ...
    def floor(self): ...
    def ceiling(self): ...
    def __floor__(self) -> int: ...
    def __ceil__(self) -> int: ...
    @property
    def num(self): ...
    def __bool__(self) -> bool: ...
    def __neg__(self): ...
    def __add__(self, other): ...
    def __sub__(self, other): ...
    def __mul__(self, other): ...
    def __truediv__(self, other): ...
    def __mod__(self, other): ...
    def __rmod__(self, other): ...
    def __abs__(self): ...
    def __int__(self) -> int: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def epsilon_eq(self, other, epsilon: str = '1e-15'): ...
    def __format__(self, format_spec) -> str: ...
RealNumber = Float

class Rational(Number):
    is_real: bool
    is_integer: bool
    is_rational: bool
    is_number: bool
    p: int
    q: int
    is_Rational: bool
    def __new__(cls, p, q: Incomplete | None = None, gcd: Incomplete | None = None): ...
    def limit_denominator(self, max_denominator: int = 1000000): ...
    def __getnewargs__(self): ...
    def __neg__(self): ...
    def __add__(self, other): ...
    __radd__ = __add__
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    __rmul__ = __mul__
    def __truediv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __mod__(self, other): ...
    def __rmod__(self, other): ...
    def __abs__(self): ...
    def __int__(self) -> int: ...
    def floor(self): ...
    def ceiling(self): ...
    def __floor__(self) -> int: ...
    def __ceil__(self) -> int: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __hash__(self): ...
    def factors(self, limit: Incomplete | None = None, use_trial: bool = True, use_rho: bool = False, use_pm1: bool = False, verbose: bool = False, visual: bool = False): ...
    @property
    def numerator(self): ...
    @property
    def denominator(self): ...
    def gcd(self, other): ...
    def lcm(self, other): ...
    def as_numer_denom(self): ...
    def as_content_primitive(self, radical: bool = False, clear: bool = True): ...
    def as_coeff_Mul(self, rational: bool = False): ...
    def as_coeff_Add(self, rational: bool = False): ...

class Integer(Rational):
    q: int
    is_integer: bool
    is_number: bool
    is_Integer: bool
    def __new__(cls, i): ...
    def __getnewargs__(self): ...
    def __int__(self) -> int: ...
    def floor(self): ...
    def ceiling(self): ...
    def __floor__(self) -> int: ...
    def __ceil__(self) -> int: ...
    def __neg__(self): ...
    def __abs__(self): ...
    def __divmod__(self, other): ...
    def __rdivmod__(self, other): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __mod__(self, other): ...
    def __rmod__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __gt__(self, other): ...
    def __lt__(self, other): ...
    def __ge__(self, other): ...
    def __le__(self, other): ...
    def __hash__(self): ...
    def __index__(self) -> int: ...
    def as_numer_denom(self): ...
    def __floordiv__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __lshift__(self, other): ...
    def __rlshift__(self, other): ...
    def __rshift__(self, other): ...
    def __rrshift__(self, other): ...
    def __and__(self, other): ...
    def __rand__(self, other): ...
    def __xor__(self, other): ...
    def __rxor__(self, other): ...
    def __or__(self, other): ...
    def __ror__(self, other): ...
    def __invert__(self): ...

class AlgebraicNumber(Expr):
    is_AlgebraicNumber: bool
    is_algebraic: bool
    is_number: bool
    kind = NumberKind
    free_symbols: set[Basic]
    def __new__(cls, expr, coeffs: Incomplete | None = None, alias: Incomplete | None = None, **args): ...
    def __hash__(self): ...
    @property
    def is_aliased(self): ...
    def as_poly(self, x: Incomplete | None = None): ...
    def as_expr(self, x: Incomplete | None = None): ...
    def coeffs(self): ...
    def native_coeffs(self): ...
    def to_algebraic_integer(self): ...
    def field_element(self, coeffs): ...
    @property
    def is_primitive_element(self): ...
    def primitive_element(self): ...
    def to_primitive_element(self, radicals: bool = True): ...
    def minpoly_of_element(self): ...
    def to_root(self, radicals: bool = True, minpoly: Incomplete | None = None): ...

class RationalConstant(Rational):
    def __new__(cls): ...

class IntegerConstant(Integer):
    def __new__(cls): ...

class Zero(IntegerConstant, metaclass=Singleton):
    p: int
    q: int
    is_positive: bool
    is_negative: bool
    is_zero: bool
    is_number: bool
    is_comparable: bool
    def __getnewargs__(self): ...
    @staticmethod
    def __abs__(): ...
    @staticmethod
    def __neg__(): ...
    def __bool__(self) -> bool: ...

class One(IntegerConstant, metaclass=Singleton):
    is_number: bool
    is_positive: bool
    p: int
    q: int
    def __init__(self) -> None: ...
    def __getnewargs__(self): ...
    @staticmethod
    def __abs__(): ...
    @staticmethod
    def __neg__(): ...
    @staticmethod
    def factors(limit: Incomplete | None = None, use_trial: bool = True, use_rho: bool = False, use_pm1: bool = False, verbose: bool = False, visual: bool = False): ...

class NegativeOne(IntegerConstant, metaclass=Singleton):
    is_number: bool
    p: int
    q: int
    def __getnewargs__(self): ...
    @staticmethod
    def __abs__(): ...
    @staticmethod
    def __neg__(): ...

class Half(RationalConstant, metaclass=Singleton):
    is_number: bool
    p: int
    q: int
    def __getnewargs__(self): ...
    @staticmethod
    def __abs__(): ...

class Infinity(Number, metaclass=Singleton):
    is_commutative: bool
    is_number: bool
    is_complex: bool
    is_extended_real: bool
    is_infinite: bool
    is_comparable: bool
    is_extended_positive: bool
    is_prime: bool
    def __new__(cls): ...
    def evalf(self, prec: Incomplete | None = None, **options): ...
    def __add__(self, other): ...
    __radd__ = __add__
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    __rmul__ = __mul__
    def __truediv__(self, other): ...
    def __abs__(self): ...
    def __neg__(self): ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    __gt__: Incomplete
    __ge__: Incomplete
    __lt__: Incomplete
    __le__: Incomplete
    def __mod__(self, other): ...
    __rmod__ = __mod__
    def floor(self): ...
    def ceiling(self): ...

oo: Incomplete

class NegativeInfinity(Number, metaclass=Singleton):
    is_extended_real: bool
    is_complex: bool
    is_commutative: bool
    is_infinite: bool
    is_comparable: bool
    is_extended_negative: bool
    is_number: bool
    is_prime: bool
    def __new__(cls): ...
    def evalf(self, prec: Incomplete | None = None, **options): ...
    def __add__(self, other): ...
    __radd__ = __add__
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    __rmul__ = __mul__
    def __truediv__(self, other): ...
    def __abs__(self): ...
    def __neg__(self): ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    __gt__: Incomplete
    __ge__: Incomplete
    __lt__: Incomplete
    __le__: Incomplete
    def __mod__(self, other): ...
    __rmod__ = __mod__
    def floor(self): ...
    def ceiling(self): ...
    def as_powers_dict(self): ...

class NaN(Number, metaclass=Singleton):
    is_commutative: bool
    is_extended_real: Incomplete
    is_real: Incomplete
    is_rational: Incomplete
    is_algebraic: Incomplete
    is_transcendental: Incomplete
    is_integer: Incomplete
    is_comparable: bool
    is_finite: Incomplete
    is_zero: Incomplete
    is_prime: Incomplete
    is_positive: Incomplete
    is_negative: Incomplete
    is_number: bool
    def __new__(cls): ...
    def __neg__(self): ...
    def __add__(self, other): ...
    def __sub__(self, other): ...
    def __mul__(self, other): ...
    def __truediv__(self, other): ...
    def floor(self): ...
    def ceiling(self): ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    __gt__: Incomplete
    __ge__: Incomplete
    __lt__: Incomplete
    __le__: Incomplete

nan: Incomplete

class ComplexInfinity(AtomicExpr, metaclass=Singleton):
    is_commutative: bool
    is_infinite: bool
    is_number: bool
    is_prime: bool
    is_complex: bool
    is_extended_real: bool
    kind = NumberKind
    def __new__(cls): ...
    @staticmethod
    def __abs__(): ...
    def floor(self): ...
    def ceiling(self): ...
    @staticmethod
    def __neg__(): ...

zoo: Incomplete

class NumberSymbol(AtomicExpr):
    is_commutative: bool
    is_finite: bool
    is_number: bool
    is_NumberSymbol: bool
    kind = NumberKind
    def __new__(cls): ...
    def approximation(self, number_cls) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __le__(self, other): ...
    def __ge__(self, other): ...
    def __int__(self) -> int: ...
    def __hash__(self): ...

class Exp1(NumberSymbol, metaclass=Singleton):
    is_real: bool
    is_positive: bool
    is_negative: bool
    is_irrational: bool
    is_number: bool
    is_algebraic: bool
    is_transcendental: bool
    @staticmethod
    def __abs__(): ...
    def __int__(self) -> int: ...
    def approximation_interval(self, number_cls): ...

E: Incomplete

class Pi(NumberSymbol, metaclass=Singleton):
    is_real: bool
    is_positive: bool
    is_negative: bool
    is_irrational: bool
    is_number: bool
    is_algebraic: bool
    is_transcendental: bool
    @staticmethod
    def __abs__(): ...
    def __int__(self) -> int: ...
    def approximation_interval(self, number_cls): ...

pi: Incomplete

class GoldenRatio(NumberSymbol, metaclass=Singleton):
    is_real: bool
    is_positive: bool
    is_negative: bool
    is_irrational: bool
    is_number: bool
    is_algebraic: bool
    is_transcendental: bool
    def __int__(self) -> int: ...
    def approximation_interval(self, number_cls): ...

class TribonacciConstant(NumberSymbol, metaclass=Singleton):
    is_real: bool
    is_positive: bool
    is_negative: bool
    is_irrational: bool
    is_number: bool
    is_algebraic: bool
    is_transcendental: bool
    def __int__(self) -> int: ...
    def approximation_interval(self, number_cls): ...

class EulerGamma(NumberSymbol, metaclass=Singleton):
    is_real: bool
    is_positive: bool
    is_negative: bool
    is_irrational: Incomplete
    is_number: bool
    def __int__(self) -> int: ...
    def approximation_interval(self, number_cls): ...

class Catalan(NumberSymbol, metaclass=Singleton):
    is_real: bool
    is_positive: bool
    is_negative: bool
    is_irrational: Incomplete
    is_number: bool
    def __int__(self) -> int: ...
    def approximation_interval(self, number_cls): ...

class ImaginaryUnit(AtomicExpr, metaclass=Singleton):
    is_commutative: bool
    is_imaginary: bool
    is_finite: bool
    is_number: bool
    is_algebraic: bool
    is_transcendental: bool
    kind = NumberKind
    @staticmethod
    def __abs__(): ...
    def as_base_exp(self): ...

I: Incomplete

def int_valued(x): ...
def equal_valued(x, y): ...
def all_close(expr1, expr2, rtol: float = 1e-05, atol: float = 1e-08): ...
def sympify_fractions(f): ...
def sympify_mpz(x): ...
def sympify_mpq(x): ...
def sympify_fmpz(x): ...
def sympify_fmpq(x): ...
def sympify_mpmath(x): ...
def sympify_complex(a): ...
