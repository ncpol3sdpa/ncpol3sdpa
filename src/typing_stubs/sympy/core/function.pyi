from .add import Add as Add
from .basic import Basic as Basic
from .cache import cacheit as cacheit
from .containers import Dict as Dict, Tuple as Tuple
from .evalf import pure_complex as pure_complex
from .expr import AtomicExpr as AtomicExpr, Expr as Expr
from .logic import (
    FuzzyBool as FuzzyBool,
    fuzzy_and as fuzzy_and,
    fuzzy_not as fuzzy_not,
    fuzzy_or as fuzzy_or,
)
from .mul import Mul as Mul
from .numbers import Float as Float, Integer as Integer, Rational as Rational
from .operations import LatticeOp as LatticeOp
from .parameters import global_parameters as global_parameters
from .rules import Transform as Transform
from .singleton import S as S
from .sorting import default_sort_key as default_sort_key, ordered as ordered
from .symbol import Dummy as Dummy, Symbol as Symbol
from .sympify import sympify as sympify
from _typeshed import Incomplete
from sympy.utilities.exceptions import (
    SymPyDeprecationWarning as SymPyDeprecationWarning,
    ignore_warnings as ignore_warnings,
    sympy_deprecation_warning as sympy_deprecation_warning,
)
from sympy.utilities.iterables import (
    has_dups as has_dups,
    is_sequence as is_sequence,
    iterable as iterable,
    sift as sift,
    topological_sort as topological_sort,
    uniq as uniq,
)
from sympy.utilities.lambdify import MPMATH_TRANSLATIONS as MPMATH_TRANSLATIONS
from sympy.utilities.misc import (
    as_int as as_int,
    filldedent as filldedent,
    func_name as func_name,
)
from typing import Any

class PoleError(Exception): ...
class ArgumentIndexError(ValueError): ...
class BadSignatureError(TypeError): ...
class BadArgumentsError(TypeError): ...

def arity(cls): ...

class FunctionClass(type):
    def __init__(cls, *args, **kwargs) -> None: ...
    @property
    def __signature__(self): ...
    @property
    def free_symbols(self): ...
    @property
    def xreplace(self): ...
    @property
    def nargs(self): ...

class Application(Basic, metaclass=FunctionClass):
    is_Function: bool
    def __new__(cls, *args, **options): ...
    @classmethod
    def eval(cls, *args) -> None: ...
    @property
    def func(self): ...

class Function(Application, Expr):
    def __new__(cls, *args, **options): ...
    @classmethod
    def class_key(cls): ...
    @classmethod
    def is_singular(cls, a): ...
    def as_base_exp(self): ...
    def fdiff(self, argindex: int = 1): ...

class AppliedUndef(Function):
    is_number: bool
    def __new__(cls, *args, **options): ...

class UndefSageHelper:
    def __get__(self, ins, typ): ...

class UndefinedFunction(FunctionClass):
    def __new__(mcl, name, bases=..., __dict__: Incomplete | None = None, **kwargs): ...
    def __instancecheck__(cls, instance): ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...

class WildFunction(Function, AtomicExpr):
    include: set[Any]
    def __init__(cls, name, **assumptions) -> None: ...
    def matches(self, expr, repl_dict: Incomplete | None = None, old: bool = False): ...

class Derivative(Expr):
    is_Derivative: bool
    def __new__(cls, expr, *variables, **kwargs): ...
    @property
    def canonical(cls): ...
    def doit(self, **hints): ...
    def doit_numerically(self, z0): ...
    @property
    def expr(self): ...
    @property
    def variables(self): ...
    @property
    def variable_count(self): ...
    @property
    def derivative_count(self): ...
    @property
    def free_symbols(self): ...
    @property
    def kind(self): ...
    def as_finite_difference(
        self,
        points: int = 1,
        x0: Incomplete | None = None,
        wrt: Incomplete | None = None,
    ): ...

class Lambda(Expr):
    is_Function: bool
    def __new__(cls, signature, expr): ...
    @property
    def signature(self): ...
    @property
    def expr(self): ...
    @property
    def variables(self): ...
    @property
    def nargs(self): ...
    bound_symbols = variables
    @property
    def free_symbols(self): ...
    def __call__(self, *args): ...
    @property
    def is_identity(self): ...

class Subs(Expr):
    def __new__(cls, expr, variables, point, **assumptions): ...
    def doit(self, **hints): ...
    def evalf(self, prec: Incomplete | None = None, **options): ...
    n = evalf
    @property
    def variables(self): ...
    bound_symbols = variables
    @property
    def expr(self): ...
    @property
    def point(self): ...
    @property
    def free_symbols(self): ...
    @property
    def expr_free_symbols(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...

def diff(f, *symbols, **kwargs): ...
def expand(
    e: Expr,
    deep: bool = True,
    modulus: Incomplete | None = None,
    power_base: bool = True,
    power_exp: bool = True,
    mul: bool = True,
    log: bool = True,
    multinomial: bool = True,
    basic: bool = True,
    **hints: Incomplete,
) -> Expr: ...
def expand_mul(expr, deep: bool = True): ...
def expand_multinomial(expr, deep: bool = True): ...
def expand_log(expr, deep: bool = True, force: bool = False, factor: bool = False): ...
def expand_func(expr, deep: bool = True): ...
def expand_trig(expr, deep: bool = True): ...
def expand_complex(expr, deep: bool = True): ...
def expand_power_base(expr, deep: bool = True, force: bool = False): ...
def expand_power_exp(expr, deep: bool = True): ...
def count_ops(expr, visual: bool = False): ...
def nfloat(expr, n: int = 15, exponent: bool = False, dkeys: bool = False): ...
