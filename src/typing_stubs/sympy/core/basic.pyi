from ._print_helpers import Printable as Printable
from .cache import cacheit as cacheit
from .kind import Kind as Kind, UndefinedKind as UndefinedKind
from .singleton import S as S
from .sorting import ordered as ordered
from .sympify import SympifyError as SympifyError, sympify as sympify
from .traversal import iterargs as iterargs, iterfreeargs as iterfreeargs
from _typeshed import Incomplete
from sympy.utilities.decorator import deprecated as deprecated
from sympy.utilities.exceptions import sympy_deprecation_warning as sympy_deprecation_warning
from sympy.utilities.iterables import iterable as iterable, numbered_symbols as numbered_symbols
from sympy.utilities.misc import filldedent as filldedent, func_name as func_name

def as_Basic(expr): ...

ordering_of_classes: Incomplete

class Basic(Printable):
    @property
    def __sympy__(self): ...
    def __init_subclass__(cls) -> None: ...
    is_number: bool
    is_Atom: bool
    is_Symbol: bool
    is_symbol: bool
    is_Indexed: bool
    is_Dummy: bool
    is_Wild: bool
    is_Function: bool
    is_Add: bool
    is_Mul: bool
    is_Pow: bool
    is_Number: bool
    is_Float: bool
    is_Rational: bool
    is_Integer: bool
    is_NumberSymbol: bool
    is_Order: bool
    is_Derivative: bool
    is_Piecewise: bool
    is_Poly: bool
    is_AlgebraicNumber: bool
    is_Relational: bool
    is_Equality: bool
    is_Boolean: bool
    is_Not: bool
    is_Matrix: bool
    is_Vector: bool
    is_Point: bool
    is_MatAdd: bool
    is_MatMul: bool
    is_real: bool | None
    is_extended_real: bool | None
    is_zero: bool | None
    is_negative: bool | None
    is_commutative: bool | None
    kind: Kind
    def __new__(cls, *args): ...
    def copy(self): ...
    def __getnewargs__(self): ...
    def __reduce_ex__(self, protocol): ...
    def __hash__(self) -> int: ...
    @property
    def assumptions0(self): ...
    def compare(self, other): ...
    @classmethod
    def fromiter(cls, args, **assumptions): ...
    @classmethod
    def class_key(cls): ...
    def sort_key(self, order: Incomplete | None = None): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def dummy_eq(self, other, symbol: Incomplete | None = None): ...
    def atoms(self, *types): ...
    @property
    def free_symbols(self) -> set[Basic]: ...
    @property
    def expr_free_symbols(self): ...
    def as_dummy(self): ...
    @property
    def canonical_variables(self): ...
    def rcall(self, *args): ...
    def is_hypergeometric(self, k): ...
    @property
    def is_comparable(self): ...
    @property
    def func(self): ...
    @property
    def args(self) -> tuple[Basic, ...]: ...
    def as_content_primitive(self, radical: bool = False, clear: bool = True): ...
    def subs(self, *args, **kwargs): ...
    def xreplace(self, rule): ...
    def has(self, *patterns): ...
    def has_xfree(self, s: set[Basic]): ...
    def has_free(self, *patterns): ...
    def replace(self, query, value, map: bool = False, simultaneous: bool = True, exact: Incomplete | None = None): ...
    def find(self, query, group: bool = False): ...
    def count(self, query): ...
    def matches(self, expr, repl_dict: Incomplete | None = None, old: bool = False): ...
    def match(self, pattern, old: bool = False): ...
    def count_ops(self, visual: Incomplete | None = None): ...
    def doit(self, **hints): ...
    def simplify(self, **kwargs): ...
    def refine(self, assumption: bool = True): ...
    def rewrite(self, *args, deep: bool = True, **hints): ...
    def could_extract_minus_sign(self): ...
    def is_same(a, b, approx: Incomplete | None = None): ...

class Atom(Basic):
    is_Atom: bool
    def matches(self, expr, repl_dict: Incomplete | None = None, old: bool = False): ...
    def xreplace(self, rule, hack2: bool = False): ...
    def doit(self, **hints): ...
    @classmethod
    def class_key(cls): ...
    def sort_key(self, order: Incomplete | None = None): ...

preorder_traversal: Incomplete
