from .numbers import AlgebraicNumber as AlgebraicNumber, Float as Float, Integer as Integer, Number as Number, Rational as Rational
from .singleton import S as S
from .sympify import sympify as sympify
from _typeshed import Incomplete
from mpmath import mpc, mpf
from mpmath.libmp import round_nearest
from sympy.concrete.products import Product as Product
from sympy.concrete.summations import Sum as Sum
from sympy.core.add import Add as Add
from sympy.core.expr import Expr as Expr
from sympy.core.mul import Mul as Mul
from sympy.core.power import Pow as Pow
from sympy.core.symbol import Symbol as Symbol
from sympy.external.gmpy import SYMPY_INTS as SYMPY_INTS
from sympy.functions.elementary.complexes import Abs as Abs, im as im, re as re
from sympy.functions.elementary.exponential import exp as exp, log as log
from sympy.functions.elementary.integers import ceiling as ceiling, floor as floor
from sympy.functions.elementary.trigonometric import atan as atan
from sympy.integrals.integrals import Integral as Integral
from sympy.utilities.iterables import is_sequence as is_sequence
from sympy.utilities.lambdify import lambdify as lambdify
from sympy.utilities.misc import as_int as as_int
from typing import Any, Callable, overload

LG10: Incomplete
rnd = round_nearest

def bitcount(n): ...

INF: Incomplete
MINUS_INF: Incomplete
DEFAULT_MAXPREC: int

class PrecisionExhausted(ArithmeticError): ...
MPF_TUP = tuple[int, int, int, int]
TMP_RES = Any
OPT_DICT = dict[str, Any]

def fastlog(x: MPF_TUP | None) -> int | Any: ...
def pure_complex(v: Expr, or_real: bool = False) -> tuple['Number', 'Number'] | None: ...
SCALED_ZERO_TUP = tuple[list[int], int, int, int]

@overload
def scaled_zero(mag: SCALED_ZERO_TUP, sign: int = 1) -> MPF_TUP: ...
@overload
def scaled_zero(mag: int, sign: int = 1) -> tuple[SCALED_ZERO_TUP, int]: ...
def iszero(mpf: MPF_TUP | SCALED_ZERO_TUP | None, scaled: bool = False) -> bool | None: ...
def complex_accuracy(result: TMP_RES) -> int | Any: ...
def get_abs(expr: Expr, prec: int, options: OPT_DICT) -> TMP_RES: ...
def get_complex_part(expr: Expr, no: int, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_abs(expr: Abs, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_re(expr: re, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_im(expr: im, prec: int, options: OPT_DICT) -> TMP_RES: ...
def finalize_complex(re: MPF_TUP, im: MPF_TUP, prec: int) -> TMP_RES: ...
def chop_parts(value: TMP_RES, prec: int) -> TMP_RES: ...
def check_target(expr: Expr, result: TMP_RES, prec: int): ...
def get_integer_part(expr: Expr, no: int, options: OPT_DICT, return_ints: bool = False) -> TMP_RES | tuple[int, int]: ...
def evalf_ceiling(expr: ceiling, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_floor(expr: floor, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_float(expr: Float, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_rational(expr: Rational, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_integer(expr: Integer, prec: int, options: OPT_DICT) -> TMP_RES: ...
def add_terms(terms: list, prec: int, target_prec: int) -> tuple[MPF_TUP | SCALED_ZERO_TUP | None, int | None]: ...
def evalf_add(v: Add, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_mul(v: Mul, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_pow(v: Pow, prec: int, options) -> TMP_RES: ...
def evalf_exp(expr: exp, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_trig(v: Expr, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_log(expr: log, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_atan(v: atan, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_subs(prec: int, subs: dict) -> dict: ...
def evalf_piecewise(expr: Expr, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_alg_num(a: AlgebraicNumber, prec: int, options: OPT_DICT) -> TMP_RES: ...
def as_mpmath(x: Any, prec: int, options: OPT_DICT) -> mpc | mpf: ...
def do_integral(expr: Integral, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_integral(expr: Integral, prec: int, options: OPT_DICT) -> TMP_RES: ...
def check_convergence(numer: Expr, denom: Expr, n: Symbol) -> tuple[int, Any, Any]: ...
def hypsum(expr: Expr, n: Symbol, start: int, prec: int) -> mpf: ...
def evalf_prod(expr: Product, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_sum(expr: Sum, prec: int, options: OPT_DICT) -> TMP_RES: ...
def evalf_symbol(x: Expr, prec: int, options: OPT_DICT) -> TMP_RES: ...

evalf_table: dict[type['Expr'], Callable[[Expr, int, OPT_DICT], TMP_RES]]

def evalf(x: Expr, prec: int, options: OPT_DICT) -> TMP_RES: ...
def quad_to_mpmath(q, ctx: Incomplete | None = None): ...

class EvalfMixin:
    def evalf(self, n: int = 15, subs: Incomplete | None = None, maxn: int = 100, chop: bool = False, strict: bool = False, quad: Incomplete | None = None, verbose: bool = False): ...
    n = evalf

def N(x, n: int = 15, **options): ...
