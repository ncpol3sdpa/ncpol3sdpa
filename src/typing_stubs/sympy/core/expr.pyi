from .add import Add as Add
from .basic import Atom as Atom, Basic as Basic
from .cache import cacheit as cacheit
from .decorators import call_highest_priority as call_highest_priority, sympify_method_args as sympify_method_args, sympify_return as sympify_return
from .evalf import DEFAULT_MAXPREC as DEFAULT_MAXPREC, EvalfMixin as EvalfMixin, pure_complex as pure_complex
from .exprtools import factor_terms as factor_terms
from .function import Function as Function
from .intfunc import mod_inverse as mod_inverse
from .kind import NumberKind as NumberKind
from .mod import Mod as Mod
from .mul import Mul as Mul
from .numbers import Float as Float, Integer as Integer, Number as Number, Rational as Rational, int_valued as int_valued
from .power import Pow as Pow
from .singleton import S as S
from .sorting import default_sort_key as default_sort_key
from .sympify import sympify as sympify
from _typeshed import Incomplete
from sympy.utilities.exceptions import sympy_deprecation_warning as sympy_deprecation_warning
from sympy.utilities.iterables import has_variety as has_variety, sift as sift
from sympy.utilities.misc import as_int as as_int, filldedent as filldedent, func_name as func_name

from typing import Dict


class Expr(Basic, EvalfMixin):
    is_scalar: bool
    def sort_key(self, order: Incomplete | None = None): ...
    def __pos__(self): ...
    def __neg__(self): ...
    def __abs__(self) -> Expr: ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __pow__(self, other, mod: Incomplete | None = None) -> Expr: ...
    def __rpow__(self, other): ...
    def __truediv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __mod__(self, other): ...
    def __rmod__(self, other): ...
    def __floordiv__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __divmod__(self, other): ...
    def __rdivmod__(self, other): ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
    def __ge__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __lt__(self, other): ...
    def __trunc__(self) -> int: ...
    def __format__(self, format_spec: str): ...
    @property
    def is_number(self): ...
    def is_constant(self, *wrt, **flags): ...
    def equals(self, other, failing_expression: bool = False): ...
    def conjugate(self): ...
    def dir(self, x, cdir): ...
    def transpose(self): ...
    def adjoint(self): ...
    def as_ordered_factors(self, order: Incomplete | None = None): ...
    def as_poly(self, *gens, **args): ...
    def as_ordered_terms(self, order: Incomplete | None = None, data: bool = False): ...
    def as_terms(self): ...
    def removeO(self): ...
    def getO(self) -> None: ...
    def getn(self): ...
    def count_ops(self, visual: Incomplete | None = None): ...
    def args_cnc(self, cset: bool = False, warn: bool = True, split_1: bool = True): ...
    def coeff(self, x, n: int = 1, right: bool = False, _first: bool = True): ...
    def as_expr(self, *gens): ...
    def as_coefficient(self, expr): ...
    def as_independent(self, *deps, **hint) -> tuple[Expr, Expr]: ...
    def as_real_imag(self, deep: bool = True, **hints): ...
    def as_powers_dict(self): ...
    def as_coefficients_dict(self : Expr, *syms : Incomplete) -> Dict[Expr, float]: ...
    def as_base_exp(self) -> tuple[Expr, Expr]: ...
    def as_coeff_mul(self, *deps, **kwargs) -> tuple[Expr, tuple[Expr, ...]]: ...
    def as_coeff_add(self, *deps) -> tuple[Expr, tuple[Expr, ...]]: ...
    def primitive(self): ...
    def as_content_primitive(self, radical: bool = False, clear: bool = True): ...
    def as_numer_denom(self): ...
    def normal(self): ...
    def extract_multiplicatively(self, c): ...
    def extract_additively(self, c): ...
    @property
    def expr_free_symbols(self): ...
    def could_extract_minus_sign(self): ...
    def extract_branch_factor(self, allow_half: bool = False): ...
    def is_polynomial(self, *syms): ...
    def is_rational_function(self, *syms): ...
    def is_meromorphic(self, x, a): ...
    def is_algebraic_expr(self, *syms): ...
    def series(self, x: Incomplete | None = None, x0: int = 0, n: int = 6, dir: str = '+', logx: Incomplete | None = None, cdir: int = 0): ...
    def aseries(self, x: Incomplete | None = None, n: int = 6, bound: int = 0, hir: bool = False): ...
    def taylor_term(self, n, x, *previous_terms): ...
    def lseries(self, x: Incomplete | None = None, x0: int = 0, dir: str = '+', logx: Incomplete | None = None, cdir: int = 0): ...
    def nseries(self, x: Incomplete | None = None, x0: int = 0, n: int = 6, dir: str = '+', logx: Incomplete | None = None, cdir: int = 0): ...
    def limit(self, x, xlim, dir: str = '+'): ...
    def compute_leading_term(self, x, logx: Incomplete | None = None): ...
    def as_leading_term(self, *symbols, logx: Incomplete | None = None, cdir: int = 0): ...
    def as_coeff_exponent(self, x) -> tuple[Expr, Expr]: ...
    def leadterm(self, x, logx: Incomplete | None = None, cdir: int = 0): ...
    def as_coeff_Mul(self, rational: bool = False) -> tuple['Number', Expr]: ...
    def as_coeff_Add(self, rational: bool = False) -> tuple['Number', Expr]: ...
    def fps(self, x: Incomplete | None = None, x0: int = 0, dir: int = 1, hyper: bool = True, order: int = 4, rational: bool = True, full: bool = False): ...
    def fourier_series(self, limits: Incomplete | None = None): ...
    def diff(self, *symbols, **assumptions): ...
    def expand(self, deep: bool = True, modulus: Incomplete | None = None, power_base: bool = True, power_exp: bool = True, mul: bool = True, log: bool = True, multinomial: bool = True, basic: bool = True, **hints): ...
    def integrate(self, *args, **kwargs): ...
    def nsimplify(self, constants=(), tolerance: Incomplete | None = None, full: bool = False): ...
    def separate(self, deep: bool = False, force: bool = False): ...
    def collect(self, syms, func: Incomplete | None = None, evaluate: bool = True, exact: bool = False, distribute_order_term: bool = True): ...
    def together(self, *args, **kwargs): ...
    def apart(self, x: Incomplete | None = None, **args): ...
    def ratsimp(self): ...
    def trigsimp(self, **args): ...
    def radsimp(self, **kwargs): ...
    def powsimp(self, *args, **kwargs): ...
    def combsimp(self): ...
    def gammasimp(self): ...
    def factor(self, *gens, **args): ...
    def cancel(self, *gens, **args): ...
    def invert(self, g, *gens, **args): ...
    def round(self, n: Incomplete | None = None): ...
    __round__ = round

class AtomicExpr(Atom, Expr):
    is_number: bool
    is_Atom: bool
    @property
    def expr_free_symbols(self): ...

class UnevaluatedExpr(Expr):
    def __new__(cls, arg, **kwargs): ...
    def doit(self, **hints): ...

def unchanged(func, *args): ...

class ExprBuilder:
    op: Incomplete
    args: Incomplete
    validator: Incomplete
    def __init__(self, op, args: Incomplete | None = None, validator: Incomplete | None = None, check: bool = True) -> None: ...
    def validate(self) -> None: ...
    def build(self, check: bool = True): ...
    def append_argument(self, arg, check: bool = True) -> None: ...
    def __getitem__(self, item): ...
    def search_element(self, elem): ...
