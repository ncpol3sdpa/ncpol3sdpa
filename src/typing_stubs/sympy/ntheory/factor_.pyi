from .digits import digits as digits
from .generate import nextprime as nextprime, primerange as primerange, sieve as sieve
from .primetest import MERSENNE_PRIME_EXPONENTS as MERSENNE_PRIME_EXPONENTS, is_mersenne_prime as is_mersenne_prime, isprime as isprime
from _typeshed import Incomplete
from sympy.core.containers import Dict as Dict
from sympy.core.intfunc import num_digits as num_digits
from sympy.core.mul import Mul as Mul
from sympy.core.numbers import Integer as Integer, Rational as Rational
from sympy.core.power import Pow as Pow
from sympy.core.singleton import S as S
from sympy.external.gmpy import SYMPY_INTS as SYMPY_INTS, bit_scan1 as bit_scan1, gcd as gcd, iroot as iroot, remove as remove, sqrtrem as sqrtrem
from sympy.utilities.decorator import deprecated as deprecated
from sympy.utilities.iterables import flatten as flatten
from sympy.utilities.misc import as_int as as_int, filldedent as filldedent

def smoothness(n): ...
def smoothness_p(n, m: int = -1, power: int = 0, visual: Incomplete | None = None): ...
def multiplicity(p, n): ...
def multiplicity_in_factorial(p, n): ...
def perfect_power(n, candidates: Incomplete | None = None, big: bool = True, factor: bool = True): ...
def pollard_rho(n, s: int = 2, a: int = 1, retries: int = 5, seed: int = 1234, max_steps: Incomplete | None = None, F: Incomplete | None = None): ...
def pollard_pm1(n, B: int = 10, a: int = 2, retries: int = 0, seed: int = 1234): ...

trial_int_msg: str
trial_msg: str
rho_msg: str
pm1_msg: str
ecm_msg: str
factor_msg: str
fermat_msg: str
complete_msg: str

def factorint(n, limit: Incomplete | None = None, use_trial: bool = True, use_rho: bool = True, use_pm1: bool = True, use_ecm: bool = True, verbose: bool = False, visual: Incomplete | None = None, multiple: bool = False): ...
def factorrat(rat, limit: Incomplete | None = None, use_trial: bool = True, use_rho: bool = True, use_pm1: bool = True, verbose: bool = False, visual: Incomplete | None = None, multiple: bool = False): ...
def primefactors(n, limit: Incomplete | None = None, verbose: bool = False, **kwargs): ...
def divisors(n, generator: bool = False, proper: bool = False): ...
def divisor_count(n, modulus: int = 1, proper: bool = False): ...
def proper_divisors(n, generator: bool = False): ...
def proper_divisor_count(n, modulus: int = 1): ...
def udivisors(n, generator: bool = False): ...
def udivisor_count(n): ...
def antidivisors(n, generator: bool = False): ...
def antidivisor_count(n): ...
def totient(n): ...
def reduced_totient(n): ...
def divisor_sigma(n, k: int = 1): ...
def core(n, t: int = 2): ...
def udivisor_sigma(n, k: int = 1): ...
def primenu(n): ...
def primeomega(n): ...
def mersenne_prime_exponent(nth): ...
def is_perfect(n): ...
def abundance(n): ...
def is_abundant(n): ...
def is_deficient(n): ...
def is_amicable(m, n): ...
def is_carmichael(n): ...
def find_carmichael_numbers_in_range(x, y): ...
def find_first_n_carmichaels(n): ...
def dra(n, b): ...
def drm(n, b): ...
