from _typeshed import Incomplete
from collections.abc import Generator
from sympy.utilities.decorator import deprecated as deprecated
from sympy.utilities.enumerative import MultisetPartitionTraverser as MultisetPartitionTraverser, list_visitor as list_visitor, multiset_partitions_taocp as multiset_partitions_taocp
from sympy.utilities.misc import as_int as as_int

def is_palindromic(s, i: int = 0, j: Incomplete | None = None): ...
def flatten(iterable, levels: Incomplete | None = None, cls: Incomplete | None = None): ...
def unflatten(iter, n: int = 2): ...
def reshape(seq, how): ...
def group(seq, multiple: bool = True): ...
def iproduct(*iterables) -> Generator[Incomplete, Incomplete]: ...
def multiset(seq): ...
def ibin(n, bits: Incomplete | None = None, str: bool = False): ...
def variations(seq, n, repetition: bool = False): ...
def subsets(seq, k: Incomplete | None = None, repetition: bool = False): ...
def filter_symbols(iterator, exclude) -> Generator[Incomplete]: ...
def numbered_symbols(prefix: str = 'x', cls: Incomplete | None = None, start: int = 0, exclude=(), *args, **assumptions) -> Generator[Incomplete]: ...
def capture(func): ...
def sift(seq, keyfunc, binary: bool = False): ...
def take(iter, n): ...
def dict_merge(*dicts): ...
def common_prefix(*seqs): ...
def common_suffix(*seqs): ...
def prefixes(seq) -> Generator[Incomplete]: ...
def postfixes(seq) -> Generator[Incomplete]: ...
def topological_sort(graph, key: Incomplete | None = None): ...
def strongly_connected_components(G): ...
def connected_components(G): ...
def rotate_left(x, y): ...
def rotate_right(x, y): ...
def least_rotation(x, key: Incomplete | None = None): ...
def multiset_combinations(m, n, g: Incomplete | None = None) -> Generator[Incomplete]: ...
def multiset_permutations(m, size: Incomplete | None = None, g: Incomplete | None = None) -> Generator[Incomplete]: ...
def multiset_partitions(multiset, m: Incomplete | None = None) -> Generator[Incomplete]: ...
def partitions(n, m: Incomplete | None = None, k: Incomplete | None = None, size: bool = False) -> Generator[Incomplete]: ...
def ordered_partitions(n, m: Incomplete | None = None, sort: bool = True) -> Generator[Incomplete]: ...
def binary_partitions(n) -> Generator[Incomplete]: ...
def has_dups(seq): ...
def has_variety(seq): ...
def uniq(seq, result: Incomplete | None = None) -> Generator[Incomplete, Incomplete]: ...
def generate_bell(n) -> Generator[Incomplete, Incomplete]: ...
def generate_involutions(n) -> Generator[Incomplete]: ...
def multiset_derangements(s) -> Generator[Incomplete, Incomplete, Incomplete]: ...
def random_derangement(t, choice: Incomplete | None = None, strict: bool = True): ...
def generate_derangements(s) -> Generator[Incomplete, Incomplete]: ...
def necklaces(n, k, free: bool = False) -> Generator[Incomplete]: ...
def bracelets(n, k): ...
def generate_oriented_forest(n) -> Generator[Incomplete]: ...
def minlex(seq, directed: bool = True, key: Incomplete | None = None): ...
def runs(seq, op=...): ...
def sequence_partitions(l, n, /) -> Generator[Incomplete]: ...
def sequence_partitions_empty(l, n, /) -> Generator[Incomplete]: ...
def kbins(l, k, ordered: Incomplete | None = None) -> Generator[Incomplete, Incomplete]: ...
def permute_signs(t) -> Generator[Incomplete]: ...
def signed_permutations(t): ...
def rotations(s, dir: int = 1) -> Generator[Incomplete]: ...
def roundrobin(*iterables) -> Generator[Incomplete]: ...

class NotIterable: ...

def iterable(i, exclude=...): ...
def is_sequence(i, include: Incomplete | None = None): ...
def postorder_traversal(node, keys: Incomplete | None = None): ...
def interactive_traversal(expr): ...
def default_sort_key(*args, **kwargs): ...
def ordered(*args, **kwargs): ...
