import ast
from _typeshed import Incomplete
from sympy.assumptions.ask import AssumptionKeys as AssumptionKeys
from sympy.core import Symbol as Symbol
from sympy.core.basic import Basic as Basic
from sympy.core.function import Function as Function
from sympy.functions.elementary.miscellaneous import Max as Max, Min as Min
from sympy.utilities.misc import func_name as func_name
from typing import Any, Callable

null: str
TOKEN = tuple[int, str]
DICT = dict[str, Any]
TRANS = Callable[[list[TOKEN], DICT, DICT], list[TOKEN]]

class ParenthesisGroup(list[TOKEN]): ...

class AppliedFunction:
    function: Incomplete
    args: Incomplete
    exponent: Incomplete
    items: Incomplete
    def __init__(self, function: TOKEN, args: ParenthesisGroup, exponent: Incomplete | None = None) -> None: ...
    def expand(self) -> list[TOKEN]: ...
    def __getitem__(self, index): ...

def function_exponentiation(tokens: list[TOKEN], local_dict: DICT, global_dict: DICT): ...
def split_symbols_custom(predicate: Callable[[str], bool]): ...

split_symbols: Incomplete

def implicit_multiplication(tokens: list[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...
def implicit_application(tokens: list[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...
def implicit_multiplication_application(result: list[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...
def auto_symbol(tokens: list[TOKEN], local_dict: DICT, global_dict: DICT): ...
def lambda_notation(tokens: list[TOKEN], local_dict: DICT, global_dict: DICT): ...
def factorial_notation(tokens: list[TOKEN], local_dict: DICT, global_dict: DICT): ...
def convert_xor(tokens: list[TOKEN], local_dict: DICT, global_dict: DICT): ...
def repeated_decimals(tokens: list[TOKEN], local_dict: DICT, global_dict: DICT): ...
def auto_number(tokens: list[TOKEN], local_dict: DICT, global_dict: DICT): ...
def rationalize(tokens: list[TOKEN], local_dict: DICT, global_dict: DICT): ...
def convert_equals_signs(tokens: list[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...

standard_transformations: tuple[TRANS, ...]

def stringify_expr(s: str, local_dict: DICT, global_dict: DICT, transformations: tuple[TRANS, ...]) -> str: ...
def eval_expr(code, local_dict: DICT, global_dict: DICT): ...
def parse_expr(s: str, local_dict: DICT | None = None, transformations: tuple[TRANS, ...] | str = ..., global_dict: DICT | None = None, evaluate: bool = True): ...
def evaluateFalse(s: str): ...

class EvaluateFalseTransformer(ast.NodeTransformer):
    operators: Incomplete
    functions: Incomplete
    relational_operators: Incomplete
    def visit_Compare(self, node): ...
    def flatten(self, args, func): ...
    def visit_BinOp(self, node): ...
    def visit_Call(self, node): ...

transformations: Incomplete

class _T:
    N: Incomplete
    def __init__(self) -> None: ...
    def __getitem__(self, t): ...

T: Incomplete
