from _typeshed import Incomplete
from collections.abc import Generator
from sympy.combinatorics import Permutation as Permutation
from sympy.combinatorics.permutations import Cycle as Cycle
from sympy.core import Basic as Basic
from sympy.core.random import choice as choice, randrange as randrange
from sympy.core.symbol import Symbol as Symbol
from sympy.functions.combinatorial.factorials import factorial as factorial
from sympy.ntheory import primefactors as primefactors, sieve as sieve
from sympy.ntheory.factor_ import factorint as factorint, multiplicity as multiplicity
from sympy.ntheory.primetest import isprime as isprime
from sympy.utilities.iterables import has_variety as has_variety, is_sequence as is_sequence, uniq as uniq

rmul: Incomplete

class PermutationGroup(Basic):
    is_group: bool
    def __new__(cls, *args, dups: bool = True, **kwargs): ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __getitem__(self, i): ...
    def __contains__(self, i) -> bool: ...
    def __len__(self) -> int: ...
    def equals(self, other): ...
    def __mul__(self, other): ...
    @property
    def base(self): ...
    def baseswap(self, base, strong_gens, pos, randomized: bool = False, transversals: Incomplete | None = None, basic_orbits: Incomplete | None = None, strong_gens_distr: Incomplete | None = None): ...
    @property
    def basic_orbits(self): ...
    @property
    def basic_stabilizers(self): ...
    @property
    def basic_transversals(self): ...
    def composition_series(self): ...
    def coset_transversal(self, H): ...
    def coset_table(self, H): ...
    def center(self): ...
    def centralizer(self, other): ...
    def commutator(self, G, H): ...
    def coset_factor(self, g, factor_index: bool = False): ...
    def generator_product(self, g, original: bool = False): ...
    def coset_rank(self, g): ...
    def coset_unrank(self, rank, af: bool = False): ...
    @property
    def degree(self): ...
    @property
    def identity(self): ...
    @property
    def elements(self): ...
    def derived_series(self): ...
    def derived_subgroup(self): ...
    def generate(self, method: str = 'coset', af: bool = False): ...
    def generate_dimino(self, af: bool = False) -> Generator[Incomplete]: ...
    def generate_schreier_sims(self, af: bool = False) -> Generator[Incomplete]: ...
    @property
    def generators(self): ...
    def contains(self, g, strict: bool = True): ...
    @property
    def is_perfect(self): ...
    @property
    def is_abelian(self): ...
    def abelian_invariants(self): ...
    def is_elementary(self, p): ...
    def is_alt_sym(self, eps: float = 0.05, _random_prec: Incomplete | None = None): ...
    @property
    def is_nilpotent(self): ...
    def is_normal(self, gr, strict: bool = True): ...
    def is_primitive(self, randomized: bool = True): ...
    def minimal_blocks(self, randomized: bool = True): ...
    @property
    def is_solvable(self): ...
    def is_subgroup(self, G, strict: bool = True): ...
    @property
    def is_polycyclic(self): ...
    def is_transitive(self, strict: bool = True): ...
    @property
    def is_trivial(self): ...
    def lower_central_series(self): ...
    @property
    def max_div(self): ...
    def minimal_block(self, points): ...
    def conjugacy_class(self, x): ...
    def conjugacy_classes(self): ...
    def normal_closure(self, other, k: int = 10): ...
    def orbit(self, alpha, action: str = 'tuples'): ...
    def orbit_rep(self, alpha, beta, schreier_vector: Incomplete | None = None): ...
    def orbit_transversal(self, alpha, pairs: bool = False): ...
    def orbits(self, rep: bool = False): ...
    def order(self): ...
    def index(self, H): ...
    @property
    def is_symmetric(self): ...
    @property
    def is_alternating(self): ...
    @property
    def is_cyclic(self): ...
    @property
    def is_dihedral(self): ...
    def pointwise_stabilizer(self, points, incremental: bool = True): ...
    def make_perm(self, n, seed: Incomplete | None = None): ...
    def random(self, af: bool = False): ...
    def random_pr(self, gen_count: int = 11, iterations: int = 50, _random_prec: Incomplete | None = None): ...
    def random_stab(self, alpha, schreier_vector: Incomplete | None = None, _random_prec: Incomplete | None = None): ...
    def schreier_sims(self) -> None: ...
    def schreier_sims_incremental(self, base: Incomplete | None = None, gens: Incomplete | None = None, slp_dict: bool = False): ...
    def schreier_sims_random(self, base: Incomplete | None = None, gens: Incomplete | None = None, consec_succ: int = 10, _random_prec: Incomplete | None = None): ...
    def schreier_vector(self, alpha): ...
    def stabilizer(self, alpha): ...
    @property
    def strong_gens(self): ...
    def subgroup(self, gens): ...
    def subgroup_search(self, prop, base: Incomplete | None = None, strong_gens: Incomplete | None = None, tests: Incomplete | None = None, init_subgroup: Incomplete | None = None): ...
    @property
    def transitivity_degree(self): ...
    def sylow_subgroup(self, p): ...
    def strong_presentation(self): ...
    def presentation(self, eliminate_gens: bool = True): ...
    def polycyclic_group(self): ...
PermGroup = PermutationGroup

class SymmetricPermutationGroup(Basic):
    def __new__(cls, deg): ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __contains__(self, i) -> bool: ...
    def order(self): ...
    @property
    def degree(self): ...
    @property
    def identity(self): ...

class Coset(Basic):
    def __new__(cls, g, H, G: Incomplete | None = None, dir: str = '+'): ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def is_left_coset(self): ...
    @property
    def is_right_coset(self): ...
    def as_list(self): ...
