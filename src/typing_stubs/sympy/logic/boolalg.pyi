from _typeshed import Incomplete
from collections.abc import Generator
from sympy.core.add import Add as Add
from sympy.core.basic import Basic as Basic
from sympy.core.cache import cacheit as cacheit
from sympy.core.containers import Tuple as Tuple
from sympy.core.decorators import sympify_method_args as sympify_method_args, sympify_return as sympify_return
from sympy.core.function import Application as Application, Derivative as Derivative
from sympy.core.kind import BooleanKind as BooleanKind, NumberKind as NumberKind
from sympy.core.numbers import Number as Number
from sympy.core.operations import LatticeOp as LatticeOp
from sympy.core.singleton import S as S, Singleton as Singleton
from sympy.core.sorting import ordered as ordered
from sympy.core.sympify import sympify as sympify
from sympy.utilities.iterables import ibin as ibin, sift as sift
from sympy.utilities.misc import filldedent as filldedent

def as_Boolean(e): ...

class Boolean(Basic):
    kind = BooleanKind
    def __and__(self, other): ...
    __rand__ = __and__
    def __or__(self, other): ...
    __ror__ = __or__
    def __invert__(self): ...
    def __rshift__(self, other): ...
    def __lshift__(self, other): ...
    __rrshift__ = __lshift__
    __rlshift__ = __rshift__
    def __xor__(self, other): ...
    __rxor__ = __xor__
    def equals(self, other): ...
    def to_nnf(self, simplify: bool = True): ...
    def as_set(self): ...
    @property
    def binary_symbols(self): ...

class BooleanAtom(Boolean):
    is_Boolean: bool
    is_Atom: bool
    def simplify(self, *a, **kw): ...
    def expand(self, *a, **kw): ...
    @property
    def canonical(self): ...
    __add__: Incomplete
    __radd__: Incomplete
    __sub__: Incomplete
    __rsub__: Incomplete
    __mul__: Incomplete
    __rmul__: Incomplete
    __pow__: Incomplete
    __rpow__: Incomplete
    __truediv__: Incomplete
    __rtruediv__: Incomplete
    __mod__: Incomplete
    __rmod__: Incomplete
    def __lt__(self, other): ...
    __le__ = __lt__
    __gt__ = __lt__
    __ge__ = __lt__

class BooleanTrue(BooleanAtom, metaclass=Singleton):
    def __bool__(self) -> bool: ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    @property
    def negated(self): ...
    def as_set(self): ...

class BooleanFalse(BooleanAtom, metaclass=Singleton):
    def __bool__(self) -> bool: ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    @property
    def negated(self): ...
    def as_set(self): ...

true: Incomplete
false: Incomplete

class BooleanFunction(Application, Boolean):
    is_Boolean: bool
    def simplify(self, **kwargs): ...
    def __lt__(self, other): ...
    __le__ = __lt__
    __ge__ = __lt__
    __gt__ = __lt__
    @classmethod
    def binary_check_and_simplify(self, *args): ...
    def to_nnf(self, simplify: bool = True): ...
    def to_anf(self, deep: bool = True): ...
    def diff(self, *symbols, **assumptions): ...

class And(LatticeOp, BooleanFunction):
    zero = false
    identity = true
    nargs: Incomplete
    def to_anf(self, deep: bool = True): ...

class Or(LatticeOp, BooleanFunction):
    zero = true
    identity = false
    def to_anf(self, deep: bool = True): ...

class Not(BooleanFunction):
    is_Not: bool
    @classmethod
    def eval(cls, arg): ...
    def to_nnf(self, simplify: bool = True): ...
    def to_anf(self, deep: bool = True): ...

class Xor(BooleanFunction):
    def __new__(cls, *args, remove_true: bool = True, **kwargs): ...
    @property
    def args(self): ...
    def to_nnf(self, simplify: bool = True): ...

class Nand(BooleanFunction):
    @classmethod
    def eval(cls, *args): ...

class Nor(BooleanFunction):
    @classmethod
    def eval(cls, *args): ...

class Xnor(BooleanFunction):
    @classmethod
    def eval(cls, *args): ...

class Implies(BooleanFunction):
    @classmethod
    def eval(cls, *args): ...
    def to_nnf(self, simplify: bool = True): ...
    def to_anf(self, deep: bool = True): ...

class Equivalent(BooleanFunction):
    def __new__(cls, *args, **options): ...
    @property
    def args(self): ...
    def to_nnf(self, simplify: bool = True): ...
    def to_anf(self, deep: bool = True): ...

class ITE(BooleanFunction):
    def __new__(cls, *args, **kwargs): ...
    @classmethod
    def eval(cls, *args): ...
    def to_nnf(self, simplify: bool = True): ...

class Exclusive(BooleanFunction):
    @classmethod
    def eval(cls, *args): ...

def conjuncts(expr): ...
def disjuncts(expr): ...
def distribute_and_over_or(expr): ...
def distribute_or_over_and(expr): ...
def distribute_xor_over_and(expr): ...
def to_anf(expr, deep: bool = True): ...
def to_nnf(expr, simplify: bool = True): ...
def to_cnf(expr, simplify: bool = False, force: bool = False): ...
def to_dnf(expr, simplify: bool = False, force: bool = False): ...
def is_anf(expr): ...
def is_nnf(expr, simplified: bool = True): ...
def is_cnf(expr): ...
def is_dnf(expr): ...
def eliminate_implications(expr): ...
def is_literal(expr): ...
def to_int_repr(clauses, symbols): ...
def term_to_integer(term): ...
integer_to_term = ibin

def truth_table(expr, variables, input: bool = True) -> Generator[Incomplete]: ...
def SOPform(variables, minterms, dontcares: Incomplete | None = None): ...
def POSform(variables, minterms, dontcares: Incomplete | None = None): ...
def ANFform(variables, truthvalues): ...
def anf_coeffs(truthvalues): ...
def bool_minterm(k, variables): ...
def bool_maxterm(k, variables): ...
def bool_monomial(k, variables): ...
def simplify_logic(expr, form: Incomplete | None = None, deep: bool = True, force: bool = False, dontcare: Incomplete | None = None): ...
def bool_map(bool1, bool2): ...
def simplify_univariate(expr): ...

BooleanGates: Incomplete

def gateinputcount(expr): ...
