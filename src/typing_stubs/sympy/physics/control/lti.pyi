from _typeshed import Incomplete
from sympy.core.basic import Basic
from sympy.core.evalf import EvalfMixin

__all__ = ['TransferFunction', 'Series', 'MIMOSeries', 'Parallel', 'MIMOParallel', 'Feedback', 'MIMOFeedback', 'TransferFunctionMatrix', 'StateSpace', 'gbt', 'bilinear', 'forward_diff', 'backward_diff', 'phase_margin', 'gain_margin']

def gbt(tf, sample_per, alpha): ...
def bilinear(tf, sample_per): ...
def forward_diff(tf, sample_per): ...
def backward_diff(tf, sample_per): ...
def phase_margin(system): ...
def gain_margin(system): ...

class LinearTimeInvariant(Basic, EvalfMixin):
    def __new__(cls, *system, **kwargs): ...
    @property
    def is_SISO(self): ...

class SISOLinearTimeInvariant(LinearTimeInvariant): ...
class MIMOLinearTimeInvariant(LinearTimeInvariant): ...

class TransferFunction(SISOLinearTimeInvariant):
    def __new__(cls, num, den, var): ...
    @classmethod
    def from_rational_expression(cls, expr, var: Incomplete | None = None): ...
    @classmethod
    def from_coeff_lists(cls, num_list, den_list, var): ...
    @classmethod
    def from_zpk(cls, zeros, poles, gain, var): ...
    @property
    def num(self): ...
    @property
    def den(self): ...
    @property
    def var(self): ...
    def expand(self): ...
    def dc_gain(self): ...
    def poles(self): ...
    def zeros(self): ...
    def eval_frequency(self, other): ...
    def is_stable(self): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    __rmul__ = __mul__
    def __truediv__(self, other): ...
    __rtruediv__ = __truediv__
    def __pow__(self, p): ...
    def __neg__(self): ...
    @property
    def is_proper(self): ...
    @property
    def is_strictly_proper(self): ...
    @property
    def is_biproper(self): ...
    def to_expr(self): ...

class Series(SISOLinearTimeInvariant):
    def __new__(cls, *args, evaluate: bool = False): ...
    @property
    def var(self): ...
    def doit(self, **hints): ...
    def __add__(self, other): ...
    __radd__ = __add__
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __truediv__(self, other): ...
    def __neg__(self): ...
    def to_expr(self): ...
    @property
    def is_proper(self): ...
    @property
    def is_strictly_proper(self): ...
    @property
    def is_biproper(self): ...

class MIMOSeries(MIMOLinearTimeInvariant):
    def __new__(cls, *args, evaluate: bool = False): ...
    @property
    def var(self): ...
    @property
    def num_inputs(self): ...
    @property
    def num_outputs(self): ...
    @property
    def shape(self): ...
    def doit(self, cancel: bool = False, **kwargs): ...
    def __add__(self, other): ...
    __radd__ = __add__
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __neg__(self): ...

class Parallel(SISOLinearTimeInvariant):
    def __new__(cls, *args, evaluate: bool = False): ...
    @property
    def var(self): ...
    def doit(self, **hints): ...
    def __add__(self, other): ...
    __radd__ = __add__
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __neg__(self): ...
    def to_expr(self): ...
    @property
    def is_proper(self): ...
    @property
    def is_strictly_proper(self): ...
    @property
    def is_biproper(self): ...

class MIMOParallel(MIMOLinearTimeInvariant):
    def __new__(cls, *args, evaluate: bool = False): ...
    @property
    def var(self): ...
    @property
    def num_inputs(self): ...
    @property
    def num_outputs(self): ...
    @property
    def shape(self): ...
    def doit(self, **hints): ...
    def __add__(self, other): ...
    __radd__ = __add__
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __neg__(self): ...

class Feedback(TransferFunction):
    def __new__(cls, sys1, sys2: Incomplete | None = None, sign: int = -1): ...
    @property
    def sys1(self): ...
    @property
    def sys2(self): ...
    @property
    def var(self): ...
    @property
    def sign(self): ...
    @property
    def num(self): ...
    @property
    def den(self): ...
    @property
    def sensitivity(self): ...
    def doit(self, cancel: bool = False, expand: bool = False, **hints): ...
    def to_expr(self): ...
    def __neg__(self): ...

class MIMOFeedback(MIMOLinearTimeInvariant):
    def __new__(cls, sys1, sys2, sign: int = -1): ...
    @property
    def sys1(self): ...
    @property
    def sys2(self): ...
    @property
    def var(self): ...
    @property
    def sign(self): ...
    @property
    def sensitivity(self): ...
    def doit(self, cancel: bool = True, expand: bool = False, **hints): ...
    def __neg__(self): ...

class TransferFunctionMatrix(MIMOLinearTimeInvariant):
    def __new__(cls, arg): ...
    @classmethod
    def from_Matrix(cls, matrix, var): ...
    @property
    def var(self): ...
    @property
    def num_inputs(self): ...
    @property
    def num_outputs(self): ...
    @property
    def shape(self): ...
    def __neg__(self): ...
    def __add__(self, other): ...
    def __sub__(self, other): ...
    def __mul__(self, other): ...
    def __getitem__(self, key): ...
    def transpose(self): ...
    def elem_poles(self): ...
    def elem_zeros(self): ...
    def eval_frequency(self, other): ...
    def expand(self, **hints): ...

class StateSpace(LinearTimeInvariant):
    def __new__(cls, A: Incomplete | None = None, B: Incomplete | None = None, C: Incomplete | None = None, D: Incomplete | None = None): ...
    @property
    def state_matrix(self): ...
    @property
    def input_matrix(self): ...
    @property
    def output_matrix(self): ...
    @property
    def feedforward_matrix(self): ...
    @property
    def num_states(self): ...
    @property
    def num_inputs(self): ...
    @property
    def num_outputs(self): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __neg__(self): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def append(self, other): ...
    def observability_matrix(self): ...
    def observable_subspace(self): ...
    def is_observable(self): ...
    def controllability_matrix(self): ...
    def controllable_subspace(self): ...
    def is_controllable(self): ...
