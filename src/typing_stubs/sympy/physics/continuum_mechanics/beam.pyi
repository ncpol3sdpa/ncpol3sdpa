from _typeshed import Incomplete
from sympy.core import S as S, Symbol as Symbol, diff as diff, symbols as symbols
from sympy.core.add import Add as Add
from sympy.core.expr import Expr as Expr
from sympy.core.function import Derivative as Derivative, Function as Function
from sympy.core.mul import Mul as Mul
from sympy.core.relational import Eq as Eq
from sympy.core.sympify import sympify as sympify
from sympy.external import import_module as import_module
from sympy.functions import Piecewise as Piecewise, SingularityFunction as SingularityFunction, factorial as factorial
from sympy.geometry.entity import GeometryEntity as GeometryEntity
from sympy.integrals import integrate as integrate
from sympy.plotting import PlotGrid as PlotGrid, plot as plot
from sympy.printing import sstr as sstr
from sympy.series import limit as limit
from sympy.sets.sets import Interval as Interval
from sympy.solvers import linsolve as linsolve
from sympy.solvers.ode.ode import dsolve as dsolve
from sympy.solvers.solvers import solve as solve
from sympy.utilities.decorator import doctest_depends_on as doctest_depends_on
from sympy.utilities.iterables import iterable as iterable
from sympy.utilities.lambdify import lambdify as lambdify

__doctest_requires__: Incomplete
numpy: Incomplete

class Beam:
    def __init__(self, length, elastic_modulus, second_moment, area=..., variable=..., base_char: str = 'C') -> None: ...
    @property
    def reaction_loads(self): ...
    @property
    def ild_shear(self): ...
    @property
    def ild_reactions(self): ...
    @property
    def ild_moment(self): ...
    @property
    def length(self): ...
    @length.setter
    def length(self, l) -> None: ...
    @property
    def area(self): ...
    @area.setter
    def area(self, a) -> None: ...
    @property
    def variable(self): ...
    @variable.setter
    def variable(self, v) -> None: ...
    @property
    def elastic_modulus(self): ...
    @elastic_modulus.setter
    def elastic_modulus(self, e) -> None: ...
    @property
    def second_moment(self): ...
    @second_moment.setter
    def second_moment(self, i) -> None: ...
    @property
    def cross_section(self): ...
    @cross_section.setter
    def cross_section(self, s) -> None: ...
    @property
    def boundary_conditions(self): ...
    @property
    def bc_slope(self): ...
    @bc_slope.setter
    def bc_slope(self, s_bcs) -> None: ...
    @property
    def bc_deflection(self): ...
    @bc_deflection.setter
    def bc_deflection(self, d_bcs) -> None: ...
    def join(self, beam, via: str = 'fixed'): ...
    def apply_support(self, loc, type: str = 'fixed'): ...
    def apply_load(self, value, start, order, end: Incomplete | None = None) -> None: ...
    def remove_load(self, value, start, order, end: Incomplete | None = None) -> None: ...
    @property
    def load(self): ...
    @property
    def applied_loads(self): ...
    def solve_for_reaction_loads(self, *reactions): ...
    def shear_force(self): ...
    def max_shear_force(self): ...
    def bending_moment(self): ...
    def max_bmoment(self): ...
    def point_cflexure(self): ...
    def slope(self): ...
    def deflection(self): ...
    def max_deflection(self): ...
    def shear_stress(self): ...
    def plot_shear_stress(self, subs: Incomplete | None = None): ...
    def plot_shear_force(self, subs: Incomplete | None = None): ...
    def plot_bending_moment(self, subs: Incomplete | None = None): ...
    def plot_slope(self, subs: Incomplete | None = None): ...
    def plot_deflection(self, subs: Incomplete | None = None): ...
    def plot_loading_results(self, subs: Incomplete | None = None): ...
    def solve_for_ild_reactions(self, value, *reactions) -> None: ...
    def plot_ild_reactions(self, subs: Incomplete | None = None): ...
    def solve_for_ild_shear(self, distance, value, *reactions) -> None: ...
    def plot_ild_shear(self, subs: Incomplete | None = None): ...
    def solve_for_ild_moment(self, distance, value, *reactions) -> None: ...
    def plot_ild_moment(self, subs: Incomplete | None = None): ...
    def draw(self, pictorial: bool = True): ...

class Beam3D(Beam):
    def __init__(self, length, elastic_modulus, shear_modulus, second_moment, area, variable=...) -> None: ...
    @property
    def shear_modulus(self): ...
    @shear_modulus.setter
    def shear_modulus(self, e) -> None: ...
    @property
    def second_moment(self): ...
    @second_moment.setter
    def second_moment(self, i) -> None: ...
    @property
    def area(self): ...
    @area.setter
    def area(self, a) -> None: ...
    @property
    def load_vector(self): ...
    @property
    def moment_load_vector(self): ...
    @property
    def boundary_conditions(self): ...
    def polar_moment(self): ...
    def apply_load(self, value, start, order, dir: str = 'y') -> None: ...
    def apply_moment_load(self, value, start, order, dir: str = 'y') -> None: ...
    def apply_support(self, loc, type: str = 'fixed') -> None: ...
    def solve_for_reaction_loads(self, *reaction) -> None: ...
    def shear_force(self): ...
    def axial_force(self): ...
    def shear_stress(self): ...
    def axial_stress(self): ...
    def bending_moment(self): ...
    def torsional_moment(self): ...
    def solve_for_torsion(self) -> None: ...
    def solve_slope_deflection(self) -> None: ...
    def slope(self): ...
    def deflection(self): ...
    def angular_deflection(self): ...
    def plot_shear_force(self, dir: str = 'all', subs: Incomplete | None = None): ...
    def plot_bending_moment(self, dir: str = 'all', subs: Incomplete | None = None): ...
    def plot_slope(self, dir: str = 'all', subs: Incomplete | None = None): ...
    def plot_deflection(self, dir: str = 'all', subs: Incomplete | None = None): ...
    def plot_loading_results(self, dir: str = 'x', subs: Incomplete | None = None): ...
    def plot_shear_stress(self, dir: str = 'all', subs: Incomplete | None = None): ...
    def max_shear_force(self): ...
    def max_bending_moment(self): ...
    max_bmoment = max_bending_moment
    def max_deflection(self): ...
