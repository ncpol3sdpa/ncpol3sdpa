from .exceptions import ClosureFailure as ClosureFailure, MissingUnityError as MissingUnityError, StructureError as StructureError
from .utilities import AlgIntPowers as AlgIntPowers, get_num_denom as get_num_denom, is_rat as is_rat
from _typeshed import Incomplete
from sympy.core.intfunc import igcd as igcd, ilcm as ilcm
from sympy.core.symbol import Dummy as Dummy
from sympy.polys.densetools import dup_clear_denoms as dup_clear_denoms
from sympy.polys.domains.algebraicfield import AlgebraicField as AlgebraicField
from sympy.polys.domains.finitefield import FF as FF
from sympy.polys.domains.integerring import ZZ as ZZ
from sympy.polys.domains.rationalfield import QQ as QQ
from sympy.polys.matrices.domainmatrix import DomainMatrix as DomainMatrix
from sympy.polys.matrices.exceptions import DMBadInputError as DMBadInputError
from sympy.polys.matrices.normalforms import hermite_normal_form as hermite_normal_form
from sympy.polys.polyclasses import ANP as ANP
from sympy.polys.polyerrors import CoercionFailed as CoercionFailed, UnificationFailed as UnificationFailed
from sympy.polys.polytools import Poly as Poly
from sympy.polys.polyutils import IntegerPowerable as IntegerPowerable

def to_col(coeffs): ...

class Module:
    @property
    def n(self) -> None: ...
    def mult_tab(self) -> None: ...
    @property
    def parent(self) -> None: ...
    def represent(self, elt) -> None: ...
    def ancestors(self, include_self: bool = False): ...
    def power_basis_ancestor(self): ...
    def nearest_common_ancestor(self, other): ...
    @property
    def number_field(self): ...
    def is_compat_col(self, col): ...
    def __call__(self, spec, denom: int = 1): ...
    def starts_with_unity(self) -> None: ...
    def basis_elements(self): ...
    def zero(self): ...
    def one(self): ...
    def element_from_rational(self, a) -> None: ...
    def submodule_from_gens(self, gens, hnf: bool = True, hnf_modulus: Incomplete | None = None): ...
    def submodule_from_matrix(self, B, denom: int = 1): ...
    def whole_submodule(self): ...
    def endomorphism_ring(self): ...

class PowerBasis(Module):
    K: Incomplete
    T: Incomplete
    def __init__(self, T) -> None: ...
    @property
    def number_field(self): ...
    def __eq__(self, other): ...
    @property
    def n(self): ...
    def mult_tab(self): ...
    def compute_mult_tab(self) -> None: ...
    def represent(self, elt): ...
    def starts_with_unity(self): ...
    def element_from_rational(self, a): ...
    def element_from_poly(self, f): ...
    def element_from_ANP(self, a): ...
    def element_from_alg_num(self, a): ...

class Submodule(Module, IntegerPowerable):
    def __init__(self, parent, matrix, denom: int = 1, mult_tab: Incomplete | None = None) -> None: ...
    def reduced(self): ...
    def discard_before(self, r): ...
    @property
    def n(self): ...
    def mult_tab(self): ...
    def compute_mult_tab(self) -> None: ...
    @property
    def parent(self): ...
    @property
    def matrix(self): ...
    @property
    def coeffs(self): ...
    @property
    def denom(self): ...
    @property
    def QQ_matrix(self): ...
    def starts_with_unity(self): ...
    def is_sq_maxrank_HNF(self): ...
    def is_power_basis_submodule(self): ...
    def element_from_rational(self, a): ...
    def basis_element_pullbacks(self): ...
    def represent(self, elt): ...
    def is_compat_submodule(self, other): ...
    def __eq__(self, other): ...
    def add(self, other, hnf: bool = True, hnf_modulus: Incomplete | None = None): ...
    def __add__(self, other): ...
    __radd__ = __add__
    def mul(self, other, hnf: bool = True, hnf_modulus: Incomplete | None = None): ...
    def __mul__(self, other): ...
    __rmul__ = __mul__
    def reduce_element(self, elt): ...

def is_sq_maxrank_HNF(dm): ...
def make_mod_elt(module, col, denom: int = 1): ...

class ModuleElement(IntegerPowerable):
    module: Incomplete
    col: Incomplete
    denom: Incomplete
    def __init__(self, module, col, denom: int = 1) -> None: ...
    def reduced(self): ...
    def reduced_mod_p(self, p): ...
    @classmethod
    def from_int_list(cls, module, coeffs, denom: int = 1): ...
    @property
    def n(self): ...
    def __len__(self) -> int: ...
    def column(self, domain: Incomplete | None = None): ...
    @property
    def coeffs(self): ...
    @property
    def QQ_col(self): ...
    def to_parent(self): ...
    def to_ancestor(self, anc): ...
    def over_power_basis(self): ...
    def is_compat(self, other): ...
    def unify(self, other): ...
    def __eq__(self, other): ...
    def equiv(self, other): ...
    def __add__(self, other): ...
    __radd__ = __add__
    def __neg__(self): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    __rmul__ = __mul__
    def __floordiv__(self, a): ...
    def __rfloordiv__(self, a): ...
    def __mod__(self, m): ...

class PowerBasisElement(ModuleElement):
    @property
    def T(self): ...
    def numerator(self, x: Incomplete | None = None): ...
    def poly(self, x: Incomplete | None = None): ...
    @property
    def is_rational(self): ...
    @property
    def generator(self): ...
    def as_expr(self, x: Incomplete | None = None): ...
    def norm(self, T: Incomplete | None = None): ...
    def inverse(self): ...
    def __rfloordiv__(self, a): ...
    def to_ANP(self): ...
    def to_alg_num(self): ...

class ModuleHomomorphism:
    domain: Incomplete
    codomain: Incomplete
    mapping: Incomplete
    def __init__(self, domain, codomain, mapping) -> None: ...
    def matrix(self, modulus: Incomplete | None = None): ...
    def kernel(self, modulus: Incomplete | None = None): ...

class ModuleEndomorphism(ModuleHomomorphism):
    def __init__(self, domain, mapping) -> None: ...

class InnerEndomorphism(ModuleEndomorphism):
    multiplier: Incomplete
    def __init__(self, domain, multiplier) -> None: ...

class EndomorphismRing:
    domain: Incomplete
    def __init__(self, domain) -> None: ...
    def inner_endomorphism(self, multiplier): ...
    def represent(self, element): ...

def find_min_poly(alpha, domain, x: Incomplete | None = None, powers: Incomplete | None = None): ...
