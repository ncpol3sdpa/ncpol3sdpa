from _typeshed import Incomplete
from sympy.core.evalf import evalf as evalf, fastlog as fastlog, quad_to_mpmath as quad_to_mpmath
from sympy.core.symbol import Dummy as Dummy, symbols as symbols
from sympy.polys.densetools import dup_eval as dup_eval
from sympy.polys.domains import ZZ as ZZ
from sympy.polys.orderings import lex as lex
from sympy.polys.polyroots import preprocess_roots as preprocess_roots
from sympy.polys.polytools import Poly as Poly
from sympy.polys.rings import xring as xring
from sympy.polys.specialpolys import symmetric_poly as symmetric_poly
from sympy.utilities.lambdify import lambdify as lambdify

class GaloisGroupException(Exception): ...
class ResolventException(GaloisGroupException): ...

class Resolvent:
    F: Incomplete
    X: Incomplete
    s: Incomplete
    m: Incomplete
    t: Incomplete
    r: int
    coeff_prec_func: Incomplete
    root_prec_func: Incomplete
    root_lambdas: Incomplete
    esf_lambdas: Incomplete
    def __init__(self, F, X, s) -> None: ...
    def get_prec(self, M, target: str = 'coeffs'): ...
    def approximate_roots_of_poly(self, T, target: str = 'coeffs'): ...
    @staticmethod
    def round_mpf(a): ...
    def round_roots_to_integers_for_poly(self, T): ...
    def eval_for_poly(self, T, find_integer_root: bool = False): ...

def wrap(text, width: int = 80): ...
def s_vars(n): ...
def sparse_symmetrize_resolvent_coeffs(F, X, s, verbose: bool = False): ...
def define_resolvents(): ...
def generate_lambda_lookup(verbose: bool = False, trial_run: bool = False): ...
def get_resolvent_by_lookup(T, number): ...
