from _typeshed import Incomplete
from sympy.core.sympify import CantSympify
from sympy.polys.domains.domainelement import DomainElement
from sympy.printing.defaults import DefaultPrinting

__all__ = ['field', 'xfield', 'vfield', 'sfield']

def field(symbols, domain, order=...): ...
def xfield(symbols, domain, order=...): ...
def vfield(symbols, domain, order=...): ...
def sfield(exprs, *symbols, **options): ...

class FracField(DefaultPrinting):
    def __new__(cls, symbols, domain, order=...): ...
    def __getnewargs__(self): ...
    def __hash__(self): ...
    def index(self, gen): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def raw_new(self, numer, denom: Incomplete | None = None): ...
    def new(self, numer, denom: Incomplete | None = None): ...
    def domain_new(self, element): ...
    def ground_new(self, element): ...
    def field_new(self, element): ...
    __call__ = field_new
    def from_expr(self, expr): ...
    def to_domain(self): ...
    def to_ring(self): ...

class FracElement(DomainElement, DefaultPrinting, CantSympify):
    numer: Incomplete
    denom: Incomplete
    def __init__(self, numer, denom: Incomplete | None = None) -> None: ...
    def raw_new(f, numer, denom): ...
    def new(f, numer, denom): ...
    def to_poly(f): ...
    def parent(self): ...
    def __getnewargs__(self): ...
    def __hash__(self): ...
    def copy(self): ...
    def set_field(self, new_field): ...
    def as_expr(self, *symbols): ...
    def __eq__(f, g): ...
    def __ne__(f, g): ...
    def __bool__(f) -> bool: ...
    def sort_key(self): ...
    def __lt__(f1, f2): ...
    def __le__(f1, f2): ...
    def __gt__(f1, f2): ...
    def __ge__(f1, f2): ...
    def __pos__(f): ...
    def __neg__(f): ...
    def __add__(f, g): ...
    def __radd__(f, c): ...
    def __sub__(f, g): ...
    def __rsub__(f, c): ...
    def __mul__(f, g): ...
    def __rmul__(f, c): ...
    def __truediv__(f, g): ...
    def __rtruediv__(f, c): ...
    def __pow__(f, n): ...
    def diff(f, x): ...
    def __call__(f, *values): ...
    def evaluate(f, x, a: Incomplete | None = None): ...
    def subs(f, x, a: Incomplete | None = None): ...
    def compose(f, x, a: Incomplete | None = None) -> None: ...
