from _typeshed import Incomplete
from sympy.polys.agca.ideals import Ideal as Ideal
from sympy.polys.domains.field import Field as Field
from sympy.polys.orderings import ProductOrder as ProductOrder, monomial_key as monomial_key
from sympy.polys.polyclasses import DMP as DMP
from sympy.polys.polyerrors import CoercionFailed as CoercionFailed
from sympy.utilities.iterables import iterable as iterable

class Module:
    ring: Incomplete
    def __init__(self, ring) -> None: ...
    def convert(self, elem, M: Incomplete | None = None): ...
    def submodule(self, *gens) -> None: ...
    def quotient_module(self, other) -> None: ...
    def __truediv__(self, e): ...
    def contains(self, elem): ...
    def __contains__(self, elem) -> bool: ...
    def subset(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def is_zero(self) -> None: ...
    def is_submodule(self, other) -> None: ...
    def multiply_ideal(self, other) -> None: ...
    def __mul__(self, e): ...
    __rmul__ = __mul__
    def identity_hom(self) -> None: ...

class ModuleElement:
    module: Incomplete
    data: Incomplete
    def __init__(self, module, data) -> None: ...
    def add(self, d1, d2): ...
    def mul(self, m, d): ...
    def div(self, m, d): ...
    def eq(self, d1, d2): ...
    def __add__(self, om): ...
    __radd__ = __add__
    def __neg__(self): ...
    def __sub__(self, om): ...
    def __rsub__(self, om): ...
    def __mul__(self, o): ...
    __rmul__ = __mul__
    def __truediv__(self, o): ...
    def __eq__(self, om): ...
    def __ne__(self, om): ...

class FreeModuleElement(ModuleElement):
    def add(self, d1, d2): ...
    def mul(self, d, p): ...
    def div(self, d, p): ...
    def __iter__(self): ...
    def __getitem__(self, idx): ...

class FreeModule(Module):
    dtype = FreeModuleElement
    rank: Incomplete
    def __init__(self, ring, rank) -> None: ...
    def is_submodule(self, other): ...
    def convert(self, elem, M: Incomplete | None = None): ...
    def is_zero(self): ...
    def basis(self): ...
    def quotient_module(self, submodule): ...
    def multiply_ideal(self, other): ...
    def identity_hom(self): ...

class FreeModulePolyRing(FreeModule):
    def __init__(self, ring, rank) -> None: ...
    def submodule(self, *gens, **opts): ...

class FreeModuleQuotientRing(FreeModule):
    quot: Incomplete
    def __init__(self, ring, rank) -> None: ...
    def submodule(self, *gens, **opts): ...
    def lift(self, elem): ...
    def unlift(self, elem): ...

class SubModule(Module):
    gens: Incomplete
    container: Incomplete
    rank: Incomplete
    ring: Incomplete
    dtype: Incomplete
    def __init__(self, gens, container) -> None: ...
    def convert(self, elem, M: Incomplete | None = None): ...
    def intersect(self, other, **options): ...
    def module_quotient(self, other, **options): ...
    def union(self, other): ...
    def is_zero(self): ...
    def submodule(self, *gens): ...
    def is_full_module(self): ...
    def is_submodule(self, other): ...
    def syzygy_module(self, **opts): ...
    def in_terms_of_generators(self, e): ...
    def reduce_element(self, x): ...
    def quotient_module(self, other, **opts): ...
    def __add__(self, oth): ...
    __radd__ = __add__
    def multiply_ideal(self, I): ...
    def inclusion_hom(self): ...
    def identity_hom(self): ...

class SubQuotientModule(SubModule):
    killed_module: Incomplete
    base: Incomplete
    def __init__(self, gens, container, **opts) -> None: ...
    def is_full_module(self): ...
    def quotient_hom(self): ...

class ModuleOrder(ProductOrder):
    def __init__(self, o1, o2, TOP) -> None: ...

class SubModulePolyRing(SubModule):
    order: Incomplete
    def __init__(self, gens, container, order: str = 'lex', TOP: bool = True) -> None: ...
    def __eq__(self, other): ...
    def reduce_element(self, x, NF: Incomplete | None = None): ...

class SubModuleQuotientRing(SubModule):
    quot: Incomplete
    def __init__(self, gens, container) -> None: ...

class QuotientModuleElement(ModuleElement):
    def eq(self, d1, d2): ...

class QuotientModule(Module):
    dtype = QuotientModuleElement
    base: Incomplete
    killed_module: Incomplete
    rank: Incomplete
    def __init__(self, ring, base, submodule) -> None: ...
    def is_zero(self): ...
    def is_submodule(self, other): ...
    def submodule(self, *gens, **opts): ...
    def convert(self, elem, M: Incomplete | None = None): ...
    def identity_hom(self): ...
    def quotient_hom(self): ...
