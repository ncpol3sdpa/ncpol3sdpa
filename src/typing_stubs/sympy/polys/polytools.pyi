from _typeshed import Incomplete
from typing import Tuple, List
from sympy.core.basic import Basic
from sympy import Expr, Symbol

__all__ = [
    "Poly",
    "PurePoly",
    "poly_from_expr",
    "parallel_poly_from_expr",
    "degree",
    "total_degree",
    "degree_list",
    "LC",
    "LM",
    "LT",
    "pdiv",
    "prem",
    "pquo",
    "pexquo",
    "div",
    "rem",
    "quo",
    "exquo",
    "half_gcdex",
    "gcdex",
    "invert",
    "subresultants",
    "resultant",
    "discriminant",
    "cofactors",
    "gcd_list",
    "gcd",
    "lcm_list",
    "lcm",
    "terms_gcd",
    "trunc",
    "monic",
    "content",
    "primitive",
    "compose",
    "decompose",
    "sturm",
    "gff_list",
    "gff",
    "sqf_norm",
    "sqf_part",
    "sqf_list",
    "sqf",
    "factor_list",
    "factor",
    "intervals",
    "refine_root",
    "count_roots",
    "all_roots",
    "real_roots",
    "nroots",
    "ground_roots",
    "nth_power_roots_poly",
    "cancel",
    "reduced",
    "groebner",
    "is_zero_dimensional",
    "GroebnerBasis",
    "poly",
]

class Poly(Basic):
    rep : Incomplete
    gens : Tuple[Symbol, ...]

    is_commutative: bool
    is_Poly: bool
    def __new__(cls, rep, *gens, **args): ...
    @classmethod
    def new(cls, rep, *gens): ...
    @property
    def expr(self): ...
    @property
    def args(self): ...
    @classmethod
    def from_dict(cls, rep, *gens, **args): ...
    @classmethod
    def from_list(cls, rep, *gens, **args): ...
    @classmethod
    def from_poly(cls, rep, *gens, **args): ...
    @classmethod
    def from_expr(cls, rep, *gens, **args): ...
    def __hash__(self): ...
    @property
    def free_symbols(self): ...
    @property
    def free_symbols_in_domain(self): ...
    @property
    def gen(self): ...
    @property
    def domain(self): ...
    @property
    def zero(self): ...
    @property
    def one(self): ...
    @property
    def unit(self): ...
    def unify(f, g): ...
    def per(
        f, rep, gens: Incomplete | None = None, remove: Incomplete | None = None
    ): ...
    def set_domain(f, domain): ...
    def get_domain(f): ...
    def set_modulus(f, modulus): ...
    def get_modulus(f): ...
    def exclude(f): ...
    def replace(f, x, y: Incomplete | None = None, **_ignore): ...
    def match(f, *args, **kwargs): ...
    def reorder(f, *gens, **args): ...
    def ltrim(f, gen): ...
    def has_only_gens(f, *gens): ...
    def to_ring(f): ...
    def to_field(f): ...
    def to_exact(f): ...
    def retract(f, field: Incomplete | None = None): ...
    def slice(f, x, m, n: Incomplete | None = None): ...
    def coeffs(f, order: Incomplete | None = None): ...
    def monoms(f, order: Incomplete | None = None): ...
    def terms(f : Poly, order: Incomplete | None = None) -> List[Tuple[Tuple[int, ...], float]]: ...
    def all_coeffs(f): ...
    def all_monoms(f): ...
    def all_terms(f): ...
    def termwise(f, func, *gens, **args): ...
    def length(f): ...
    def as_dict(f, native: bool = False, zero: bool = False): ...
    def as_list(f, native: bool = False): ...
    def as_expr(f : Poly, *gens) -> Expr: ...
    def as_poly(self, *gens, **args): ...
    def lift(f): ...
    def deflate(f): ...
    def inject(f, front: bool = False): ...
    def eject(f, *gens): ...
    def terms_gcd(f): ...
    def add_ground(f, coeff): ...
    def sub_ground(f, coeff): ...
    def mul_ground(f, coeff): ...
    def quo_ground(f, coeff): ...
    def exquo_ground(f, coeff): ...
    def abs(f): ...
    def neg(f): ...
    def add(f, g): ...
    def sub(f, g): ...
    def mul(f, g): ...
    def sqr(f): ...
    def pow(f, n): ...
    def pdiv(f, g): ...
    def prem(f, g): ...
    def pquo(f, g): ...
    def pexquo(f, g): ...
    def div(f, g, auto: bool = True): ...
    def rem(f : Poly, g : Poly, auto: bool = True) -> Poly: ...
    def quo(f, g, auto: bool = True): ...
    def exquo(f, g, auto: bool = True): ...
    def degree(f, gen: int = 0): ...
    def degree_list(f): ...
    def total_degree(f: Poly) -> int: ...
    def homogenize(f, s): ...
    def homogeneous_order(f): ...
    def LC(f, order: Incomplete | None = None): ...
    def TC(f): ...
    def EC(f, order: Incomplete | None = None): ...
    def coeff_monomial(f, monom): ...
    def nth(f, *N): ...
    def coeff(f, x, n: int = 1, right: bool = False) -> None: ...
    def LM(f, order: Incomplete | None = None): ...
    def EM(f, order: Incomplete | None = None): ...
    def LT(f, order: Incomplete | None = None): ...
    def ET(f, order: Incomplete | None = None): ...
    def max_norm(f): ...
    def l1_norm(f): ...
    def clear_denoms(self, convert: bool = False): ...
    def rat_clear_denoms(self, g): ...
    def integrate(self, *specs, **args): ...
    def diff(f, *specs, **kwargs): ...
    def eval(self, x, a: Incomplete | None = None, auto: bool = True): ...
    def __call__(f, *values): ...
    def half_gcdex(f, g, auto: bool = True): ...
    def gcdex(f, g, auto: bool = True): ...
    def invert(f, g, auto: bool = True): ...
    def revert(f, n): ...
    def subresultants(f, g): ...
    def resultant(f, g, includePRS: bool = False): ...
    def discriminant(f): ...
    def dispersionset(f, g: Incomplete | None = None): ...
    def dispersion(f, g: Incomplete | None = None): ...
    def cofactors(f, g): ...
    def gcd(f, g): ...
    def lcm(f, g): ...
    def trunc(f, p): ...
    def monic(self, auto: bool = True): ...
    def content(f): ...
    def primitive(f): ...
    def compose(f, g): ...
    def decompose(f): ...
    def shift(f, a): ...
    def shift_list(f, a): ...
    def transform(f, p, q): ...
    def sturm(self, auto: bool = True): ...
    def gff_list(f): ...
    def norm(f): ...
    def sqf_norm(f): ...
    def sqf_part(f): ...
    def sqf_list(f, all: bool = False): ...
    def sqf_list_include(f, all: bool = False): ...
    def factor_list(f): ...
    def factor_list_include(f): ...
    def intervals(
        f,
        all: bool = False,
        eps: Incomplete | None = None,
        inf: Incomplete | None = None,
        sup: Incomplete | None = None,
        fast: bool = False,
        sqf: bool = False,
    ): ...
    def refine_root(
        f,
        s,
        t,
        eps: Incomplete | None = None,
        steps: Incomplete | None = None,
        fast: bool = False,
        check_sqf: bool = False,
    ): ...
    def count_roots(
        f, inf: Incomplete | None = None, sup: Incomplete | None = None
    ): ...
    def root(f, index, radicals: bool = True): ...
    def real_roots(f, multiple: bool = True, radicals: bool = True): ...
    def all_roots(f, multiple: bool = True, radicals: bool = True): ...
    def nroots(f, n: int = 15, maxsteps: int = 50, cleanup: bool = True): ...
    def ground_roots(f): ...
    def nth_power_roots_poly(f, n): ...
    def same_root(f, a, b): ...
    def cancel(f, g, include: bool = False): ...
    def make_monic_over_integers_by_scaling_roots(f): ...
    def galois_group(
        f, by_name: bool = False, max_tries: int = 30, randomize: bool = False
    ): ...
    @property
    def is_zero(f): ...
    @property
    def is_one(f): ...
    @property
    def is_sqf(f): ...
    @property
    def is_monic(f): ...
    @property
    def is_primitive(f): ...
    @property
    def is_ground(f): ...
    @property
    def is_linear(f): ...
    @property
    def is_quadratic(f): ...
    @property
    def is_monomial(f): ...
    @property
    def is_homogeneous(f): ...
    @property
    def is_irreducible(f): ...
    @property
    def is_univariate(f): ...
    @property
    def is_multivariate(f): ...
    @property
    def is_cyclotomic(f): ...
    def __abs__(f): ...
    def __neg__(f): ...
    def __add__(f, g): ...
    def __radd__(f, g): ...
    def __sub__(f, g): ...
    def __rsub__(f, g): ...
    def __mul__(f, g): ...
    def __rmul__(f, g): ...
    def __pow__(f, n): ...
    def __divmod__(f, g): ...
    def __rdivmod__(f, g): ...
    def __mod__(f, g): ...
    def __rmod__(f, g): ...
    def __floordiv__(f, g): ...
    def __rfloordiv__(f, g): ...
    def __truediv__(f, g): ...
    def __rtruediv__(f, g): ...
    def __eq__(self, other): ...
    def __ne__(f, g): ...
    def __bool__(f) -> bool: ...
    def eq(f, g, strict: bool = False): ...
    def ne(f, g, strict: bool = False): ...

class PurePoly(Poly):
    def __hash__(self): ...
    @property
    def free_symbols(self): ...
    def __eq__(self, other): ...

def poly_from_expr(expr, *gens, **args): ...
def parallel_poly_from_expr(exprs, *gens, **args): ...
def degree(f, gen: int = 0): ...
def total_degree(f : Expr | Poly, *gens : Incomplete) -> int : ...
def degree_list(f, *gens, **args): ...
def LC(f, *gens, **args): ...
def LM(f, *gens, **args): ...
def LT(f, *gens, **args): ...
def pdiv(f, g, *gens, **args): ...
def prem(f, g, *gens, **args): ...
def pquo(f, g, *gens, **args): ...
def pexquo(f, g, *gens, **args): ...
def div(f, g, *gens, **args): ...
def rem(f : Poly | Expr, g : Poly | Expr, *gens : Incomplete, **args : Incomplete) -> Poly: ...
def quo(f, g, *gens, **args): ...
def exquo(f, g, *gens, **args): ...
def half_gcdex(f, g, *gens, **args): ...
def gcdex(f, g, *gens, **args): ...
def invert(f, g, *gens, **args): ...
def subresultants(f, g, *gens, **args): ...
def resultant(f, g, *gens, includePRS: bool = False, **args): ...
def discriminant(f, *gens, **args): ...
def cofactors(f, g, *gens, **args): ...
def gcd_list(seq, *gens, **args): ...
def gcd(f, g: Incomplete | None = None, *gens, **args): ...
def lcm_list(seq, *gens, **args): ...
def lcm(f, g: Incomplete | None = None, *gens, **args): ...
def terms_gcd(f, *gens, **args): ...
def trunc(f, p, *gens, **args): ...
def monic(f, *gens, **args): ...
def content(f, *gens, **args): ...
def primitive(f, *gens, **args): ...
def compose(f, g, *gens, **args): ...
def decompose(f, *gens, **args): ...
def sturm(f, *gens, **args): ...
def gff_list(f, *gens, **args): ...
def gff(f, *gens, **args) -> None: ...
def sqf_norm(f, *gens, **args): ...
def sqf_part(f, *gens, **args): ...
def sqf_list(f, *gens, **args): ...
def sqf(f, *gens, **args): ...
def factor_list(f, *gens, **args): ...
def factor(f, *gens, deep: bool = False, **args): ...
def intervals(
    F,
    all: bool = False,
    eps: Incomplete | None = None,
    inf: Incomplete | None = None,
    sup: Incomplete | None = None,
    strict: bool = False,
    fast: bool = False,
    sqf: bool = False,
): ...
def refine_root(
    f,
    s,
    t,
    eps: Incomplete | None = None,
    steps: Incomplete | None = None,
    fast: bool = False,
    check_sqf: bool = False,
): ...
def count_roots(f, inf: Incomplete | None = None, sup: Incomplete | None = None): ...
def all_roots(f, multiple: bool = True, radicals: bool = True): ...
def real_roots(f, multiple: bool = True, radicals: bool = True): ...
def nroots(f, n: int = 15, maxsteps: int = 50, cleanup: bool = True): ...
def ground_roots(f, *gens, **args): ...
def nth_power_roots_poly(f, n, *gens, **args): ...
def cancel(f, *gens, _signsimp: bool = True, **args): ...
def reduced(f, G, *gens, **args): ...
def groebner(F, *gens, **args): ...
def is_zero_dimensional(F, *gens, **args): ...

class GroebnerBasis(Basic):
    def __new__(cls, F, *gens, **args): ...
    @property
    def args(self): ...
    @property
    def exprs(self): ...
    @property
    def polys(self): ...
    @property
    def gens(self): ...
    @property
    def domain(self): ...
    @property
    def order(self): ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __getitem__(self, item): ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    @property
    def is_zero_dimensional(self): ...
    def fglm(self, order): ...
    def reduce(self, expr, auto: bool = True): ...
    def contains(self, poly): ...

def poly(expr: Expr, *gens: Incomplete, **args: Incomplete) -> Poly: ...
