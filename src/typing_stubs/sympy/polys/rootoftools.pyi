from _typeshed import Incomplete
from sympy.core import Expr

__all__ = ['CRootOf', 'rootof', 'RootOf', 'ComplexRootOf', 'RootSum']

class _pure_key_dict:
    def __init__(self) -> None: ...
    def __getitem__(self, k): ...
    def __setitem__(self, k, v) -> None: ...
    def __contains__(self, k) -> bool: ...

def rootof(f, x, index: Incomplete | None = None, radicals: bool = True, expand: bool = True): ...

class RootOf(Expr):
    def __new__(cls, f, x, index: Incomplete | None = None, radicals: bool = True, expand: bool = True): ...

class ComplexRootOf(RootOf):
    is_complex: bool
    is_number: bool
    is_finite: bool
    def __new__(cls, f, x, index: Incomplete | None = None, radicals: bool = False, expand: bool = True): ...
    @property
    def expr(self): ...
    @property
    def args(self): ...
    @property
    def free_symbols(self): ...
    @classmethod
    def real_roots(cls, poly, radicals: bool = True): ...
    @classmethod
    def all_roots(cls, poly, radicals: bool = True): ...
    @classmethod
    def clear_cache(cls) -> None: ...
    def eval_approx(self, n, return_mpmath: bool = False): ...
    def eval_rational(self, dx: Incomplete | None = None, dy: Incomplete | None = None, n: int = 15): ...
CRootOf = ComplexRootOf

class RootSum(Expr):
    def __new__(cls, expr, func: Incomplete | None = None, x: Incomplete | None = None, auto: bool = True, quadratic: bool = False): ...
    @classmethod
    def new(cls, poly, func, auto: bool = True): ...
    @property
    def expr(self): ...
    @property
    def args(self): ...
    @property
    def free_symbols(self): ...
    @property
    def is_commutative(self): ...
    def doit(self, **hints): ...
