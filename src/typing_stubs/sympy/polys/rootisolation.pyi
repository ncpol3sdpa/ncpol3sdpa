from _typeshed import Incomplete
from sympy.polys.densearith import dup_l2_norm_squared as dup_l2_norm_squared, dup_neg as dup_neg, dup_rem as dup_rem, dup_rshift as dup_rshift
from sympy.polys.densebasic import dup_LC as dup_LC, dup_TC as dup_TC, dup_convert as dup_convert, dup_degree as dup_degree, dup_reverse as dup_reverse, dup_strip as dup_strip, dup_terms_gcd as dup_terms_gcd
from sympy.polys.densetools import dmp_eval_in as dmp_eval_in, dup_clear_denoms as dup_clear_denoms, dup_diff as dup_diff, dup_eval as dup_eval, dup_mirror as dup_mirror, dup_real_imag as dup_real_imag, dup_scale as dup_scale, dup_shift as dup_shift, dup_sign_variations as dup_sign_variations, dup_transform as dup_transform
from sympy.polys.euclidtools import dup_discriminant as dup_discriminant
from sympy.polys.factortools import dup_factor_list as dup_factor_list
from sympy.polys.polyerrors import DomainError as DomainError, PolynomialError as PolynomialError, RefinementFailed as RefinementFailed
from sympy.polys.sqfreetools import dup_sqf_list as dup_sqf_list, dup_sqf_part as dup_sqf_part

def dup_sturm(f, K): ...
def dup_root_upper_bound(f, K): ...
def dup_root_lower_bound(f, K): ...
def dup_cauchy_upper_bound(f, K): ...
def dup_cauchy_lower_bound(f, K): ...
def dup_mignotte_sep_bound_squared(f, K): ...
def dup_step_refine_real_root(f, M, K, fast: bool = False): ...
def dup_inner_refine_real_root(f, M, K, eps: Incomplete | None = None, steps: Incomplete | None = None, disjoint: Incomplete | None = None, fast: bool = False, mobius: bool = False): ...
def dup_outer_refine_real_root(f, s, t, K, eps: Incomplete | None = None, steps: Incomplete | None = None, disjoint: Incomplete | None = None, fast: bool = False): ...
def dup_refine_real_root(f, s, t, K, eps: Incomplete | None = None, steps: Incomplete | None = None, disjoint: Incomplete | None = None, fast: bool = False): ...
def dup_inner_isolate_real_roots(f, K, eps: Incomplete | None = None, fast: bool = False): ...
def dup_inner_isolate_positive_roots(f, K, eps: Incomplete | None = None, inf: Incomplete | None = None, sup: Incomplete | None = None, fast: bool = False, mobius: bool = False): ...
def dup_inner_isolate_negative_roots(f, K, inf: Incomplete | None = None, sup: Incomplete | None = None, eps: Incomplete | None = None, fast: bool = False, mobius: bool = False): ...
def dup_isolate_real_roots_sqf(f, K, eps: Incomplete | None = None, inf: Incomplete | None = None, sup: Incomplete | None = None, fast: bool = False, blackbox: bool = False): ...
def dup_isolate_real_roots(f, K, eps: Incomplete | None = None, inf: Incomplete | None = None, sup: Incomplete | None = None, basis: bool = False, fast: bool = False): ...
def dup_isolate_real_roots_list(polys, K, eps: Incomplete | None = None, inf: Incomplete | None = None, sup: Incomplete | None = None, strict: bool = False, basis: bool = False, fast: bool = False): ...
def dup_count_real_roots(f, K, inf: Incomplete | None = None, sup: Incomplete | None = None): ...

OO: str
Q1: str
Q2: str
Q3: str
Q4: str
A1: str
A2: str
A3: str
A4: str

def dup_count_complex_roots(f, K, inf: Incomplete | None = None, sup: Incomplete | None = None, exclude: Incomplete | None = None): ...
def dup_isolate_complex_roots_sqf(f, K, eps: Incomplete | None = None, inf: Incomplete | None = None, sup: Incomplete | None = None, blackbox: bool = False): ...
def dup_isolate_all_roots_sqf(f, K, eps: Incomplete | None = None, inf: Incomplete | None = None, sup: Incomplete | None = None, fast: bool = False, blackbox: bool = False): ...
def dup_isolate_all_roots(f, K, eps: Incomplete | None = None, inf: Incomplete | None = None, sup: Incomplete | None = None, fast: bool = False): ...

class RealInterval:
    neg: bool
    mobius: Incomplete
    def __init__(self, data, f, dom) -> None: ...
    @property
    def func(self): ...
    @property
    def args(self): ...
    def __eq__(self, other): ...
    @property
    def a(self): ...
    @property
    def b(self): ...
    @property
    def dx(self): ...
    @property
    def center(self): ...
    @property
    def max_denom(self): ...
    def as_tuple(self): ...
    def __contains__(self, item) -> bool: ...
    def is_disjoint(self, other): ...
    def refine_disjoint(self, other): ...
    def refine_size(self, dx): ...
    def refine_step(self, steps: int = 1): ...
    def refine(self): ...

class ComplexInterval:
    dom: Incomplete
    conj: Incomplete
    def __init__(self, a, b, I, Q, F1, F2, f1, f2, dom, conj: bool = False) -> None: ...
    @property
    def func(self): ...
    @property
    def args(self): ...
    def __eq__(self, other): ...
    @property
    def ax(self): ...
    @property
    def ay(self): ...
    @property
    def bx(self): ...
    @property
    def by(self): ...
    @property
    def dx(self): ...
    @property
    def dy(self): ...
    @property
    def center(self): ...
    @property
    def max_denom(self): ...
    def as_tuple(self): ...
    def conjugate(self): ...
    def __contains__(self, item) -> bool: ...
    def is_disjoint(self, other): ...
    def refine_disjoint(self, other): ...
    def refine_size(self, dx, dy: Incomplete | None = None): ...
    def refine_step(self, steps: int = 1): ...
    def refine(self): ...
