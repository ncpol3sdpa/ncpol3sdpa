from _typeshed import Incomplete
from sympy.combinatorics import Permutation as Permutation
from sympy.core import Add as Add, Basic as Basic, Dict as Dict, Expr as Expr, Function as Function, Lambda as Lambda, Mul as Mul, Pow as Pow, S as S, Tuple as Tuple, diff as diff
from sympy.core.cache import cacheit as cacheit
from sympy.core.symbol import Dummy as Dummy, Str as Str, Symbol as Symbol
from sympy.functions import factorial as factorial
from sympy.simplify.simplify import simplify as simplify
from sympy.solvers import solve as solve
from sympy.tensor.array import ImmutableDenseNDimArray as ImmutableDenseNDimArray
from sympy.utilities.exceptions import SymPyDeprecationWarning as SymPyDeprecationWarning, ignore_warnings as ignore_warnings, sympy_deprecation_warning as sympy_deprecation_warning
from typing import Any

class Manifold(Basic):
    def __new__(cls, name, dim, **kwargs): ...
    @property
    def name(self): ...
    @property
    def dim(self): ...

class Patch(Basic):
    def __new__(cls, name, manifold, **kwargs): ...
    @property
    def name(self): ...
    @property
    def manifold(self): ...
    @property
    def dim(self): ...

class CoordSystem(Basic):
    def __new__(cls, name, patch, symbols: Incomplete | None = None, relations={}, **kwargs): ...
    @property
    def name(self): ...
    @property
    def patch(self): ...
    @property
    def manifold(self): ...
    @property
    def symbols(self): ...
    @property
    def relations(self): ...
    @property
    def dim(self): ...
    def transformation(self, sys): ...
    def connect_to(self, to_sys, from_coords, to_exprs, inverse: bool = True, fill_in_gaps: bool = False) -> None: ...
    def transform(self, sys, coordinates: Incomplete | None = None): ...
    def coord_tuple_transform_to(self, to_sys, coords): ...
    def jacobian(self, sys, coordinates: Incomplete | None = None): ...
    jacobian_matrix = jacobian
    def jacobian_determinant(self, sys, coordinates: Incomplete | None = None): ...
    def point(self, coords): ...
    def point_to_coords(self, point): ...
    def base_scalar(self, coord_index): ...
    coord_function = base_scalar
    def base_scalars(self): ...
    coord_functions = base_scalars
    def base_vector(self, coord_index): ...
    def base_vectors(self): ...
    def base_oneform(self, coord_index): ...
    def base_oneforms(self): ...

class CoordinateSymbol(Symbol):
    def __new__(cls, coord_sys, index, **assumptions): ...
    def __getnewargs__(self): ...

class Point(Basic):
    def __new__(cls, coord_sys, coords, **kwargs): ...
    @property
    def patch(self): ...
    @property
    def manifold(self): ...
    @property
    def dim(self): ...
    def coords(self, sys: Incomplete | None = None): ...
    @property
    def free_symbols(self): ...

class BaseScalarField(Expr):
    is_commutative: bool
    def __new__(cls, coord_sys, index, **kwargs): ...
    @property
    def coord_sys(self): ...
    @property
    def index(self): ...
    @property
    def patch(self): ...
    @property
    def manifold(self): ...
    @property
    def dim(self): ...
    def __call__(self, *args): ...
    free_symbols: set[Any]

class BaseVectorField(Expr):
    is_commutative: bool
    def __new__(cls, coord_sys, index, **kwargs): ...
    @property
    def coord_sys(self): ...
    @property
    def index(self): ...
    @property
    def patch(self): ...
    @property
    def manifold(self): ...
    @property
    def dim(self): ...
    def __call__(self, scalar_field): ...

class Commutator(Expr):
    def __new__(cls, v1, v2): ...
    @property
    def v1(self): ...
    @property
    def v2(self): ...
    def __call__(self, scalar_field): ...

class Differential(Expr):
    is_commutative: bool
    def __new__(cls, form_field): ...
    @property
    def form_field(self): ...
    def __call__(self, *vector_fields): ...

class TensorProduct(Expr):
    def __new__(cls, *args): ...
    def __call__(self, *fields): ...

class WedgeProduct(TensorProduct):
    def __call__(self, *fields): ...

class LieDerivative(Expr):
    def __new__(cls, v_field, expr): ...
    @property
    def v_field(self): ...
    @property
    def expr(self): ...
    def __call__(self, *args): ...

class BaseCovarDerivativeOp(Expr):
    def __new__(cls, coord_sys, index, christoffel): ...
    @property
    def coord_sys(self): ...
    @property
    def index(self): ...
    @property
    def christoffel(self): ...
    def __call__(self, field): ...

class CovarDerivativeOp(Expr):
    def __new__(cls, wrt, christoffel): ...
    @property
    def wrt(self): ...
    @property
    def christoffel(self): ...
    def __call__(self, field): ...

def intcurve_series(vector_field, param, start_point, n: int = 6, coord_sys: Incomplete | None = None, coeffs: bool = False): ...
def intcurve_diffequ(vector_field, param, start_point, coord_sys: Incomplete | None = None): ...
def dummyfy(args, exprs): ...
def contravariant_order(expr, _strict: bool = False): ...
def covariant_order(expr, _strict: bool = False): ...
def vectors_in_basis(expr, to_sys): ...
def twoform_to_matrix(expr): ...
def metric_to_Christoffel_1st(expr): ...
def metric_to_Christoffel_2nd(expr): ...
def metric_to_Riemann_components(expr): ...
def metric_to_Ricci_components(expr): ...

class _deprecated_container:
    message: Incomplete
    def __init__(self, message, data) -> None: ...
    def warn(self) -> None: ...
    def __iter__(self): ...
    def __getitem__(self, key): ...
    def __contains__(self, key) -> bool: ...

class _deprecated_list(_deprecated_container, list): ...
class _deprecated_dict(_deprecated_container, dict): ...
