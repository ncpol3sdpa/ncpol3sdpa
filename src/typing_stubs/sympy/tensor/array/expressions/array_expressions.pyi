import typing
from _typeshed import Incomplete
from sympy.combinatorics import Permutation as Permutation
from sympy.core.basic import Basic as Basic
from sympy.core.containers import Tuple as Tuple
from sympy.core.expr import Expr as Expr
from sympy.core.function import Function as Function, Lambda as Lambda
from sympy.core.mul import Mul as Mul
from sympy.core.numbers import Integer as Integer
from sympy.core.relational import Equality as Equality
from sympy.core.singleton import S as S
from sympy.core.sorting import default_sort_key as default_sort_key
from sympy.core.symbol import Dummy as Dummy, Symbol as Symbol
from sympy.functions.special.tensor_functions import KroneckerDelta as KroneckerDelta
from sympy.matrices.expressions.diagonal import diagonalize_vector as diagonalize_vector
from sympy.matrices.expressions.matexpr import MatrixElement as MatrixElement, MatrixExpr as MatrixExpr
from sympy.matrices.expressions.special import ZeroMatrix as ZeroMatrix
from sympy.matrices.matrixbase import MatrixBase as MatrixBase
from sympy.tensor.array.arrayop import permutedims as permutedims, tensorcontraction as tensorcontraction, tensordiagonal as tensordiagonal, tensorproduct as tensorproduct
from sympy.tensor.array.dense_ndim_array import ImmutableDenseNDimArray as ImmutableDenseNDimArray
from sympy.tensor.array.ndim_array import NDimArray as NDimArray
from sympy.tensor.indexed import Indexed as Indexed, IndexedBase as IndexedBase

class _ArrayExpr(Expr):
    shape: tuple[Expr, ...]
    def __getitem__(self, item): ...

class ArraySymbol(_ArrayExpr):
    def __new__(cls, symbol, shape: typing.Iterable) -> ArraySymbol: ...
    @property
    def name(self): ...
    @property
    def shape(self): ...
    def as_explicit(self): ...

class ArrayElement(Expr):
    is_symbol: bool
    is_commutative: bool
    def __new__(cls, name, indices): ...
    @property
    def name(self): ...
    @property
    def indices(self): ...

class ZeroArray(_ArrayExpr):
    def __new__(cls, *shape): ...
    @property
    def shape(self): ...
    def as_explicit(self): ...

class OneArray(_ArrayExpr):
    def __new__(cls, *shape): ...
    @property
    def shape(self): ...
    def as_explicit(self): ...

class _CodegenArrayAbstract(Basic):
    @property
    def subranks(self): ...
    def subrank(self): ...
    @property
    def shape(self): ...
    def doit(self, **hints): ...

class ArrayTensorProduct(_CodegenArrayAbstract):
    def __new__(cls, *args, **kwargs): ...
    def as_explicit(self): ...

class ArrayAdd(_CodegenArrayAbstract):
    def __new__(cls, *args, **kwargs): ...
    def as_explicit(self): ...

class PermuteDims(_CodegenArrayAbstract):
    def __new__(cls, expr, permutation: Incomplete | None = None, index_order_old: Incomplete | None = None, index_order_new: Incomplete | None = None, **kwargs): ...
    @property
    def expr(self): ...
    @property
    def permutation(self): ...
    def nest_permutation(self): ...
    def as_explicit(self): ...

class ArrayDiagonal(_CodegenArrayAbstract):
    def __new__(cls, expr, *diagonal_indices, **kwargs): ...
    @property
    def expr(self): ...
    @property
    def diagonal_indices(self): ...
    def as_explicit(self): ...

class ArrayElementwiseApplyFunc(_CodegenArrayAbstract):
    def __new__(cls, function, element): ...
    @property
    def function(self): ...
    @property
    def expr(self): ...
    @property
    def shape(self): ...
    def as_explicit(self): ...

class ArrayContraction(_CodegenArrayAbstract):
    def __new__(cls, expr, *contraction_indices, **kwargs): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def split_multiple_contractions(self): ...
    def flatten_contraction_of_diagonal(self): ...
    @property
    def free_indices(self): ...
    @property
    def free_indices_to_position(self): ...
    @property
    def expr(self): ...
    @property
    def contraction_indices(self): ...
    def sort_args_by_name(self): ...
    def as_explicit(self): ...

class Reshape(_CodegenArrayAbstract):
    def __new__(cls, expr, shape): ...
    @property
    def shape(self): ...
    @property
    def expr(self): ...
    def doit(self, *args, **kwargs): ...
    def as_explicit(self): ...

class _ArgE:
    indices: list[int | None]
    element: Incomplete
    def __init__(self, element, indices: list[int | None] | None = None) -> None: ...

class _IndPos:
    arg: Incomplete
    rel: Incomplete
    def __init__(self, arg: int, rel: int) -> None: ...
    def __iter__(self): ...

class _EditArrayContraction:
    args_with_ind: list[_ArgE]
    number_of_contraction_indices: int
    def __init__(self, base_array: ArrayContraction | ArrayDiagonal | ArrayTensorProduct) -> None: ...
    def insert_after(self, arg: _ArgE, new_arg: _ArgE): ...
    def get_new_contraction_index(self): ...
    def refresh_indices(self) -> None: ...
    def merge_scalars(self) -> None: ...
    def to_array_contraction(self): ...
    def get_contraction_indices(self) -> list[list[int]]: ...
    def get_mapping_for_index(self, ind) -> list[_IndPos]: ...
    def get_contraction_indices_to_ind_rel_pos(self) -> list[list[_IndPos]]: ...
    def count_args_with_index(self, index: int) -> int: ...
    def get_args_with_index(self, index: int) -> list[_ArgE]: ...
    @property
    def number_of_diagonal_indices(self): ...
    def track_permutation_start(self) -> None: ...
    def track_permutation_merge(self, destination: _ArgE, from_element: _ArgE): ...
    def get_absolute_free_range(self, arg: _ArgE) -> tuple[int, int]: ...
    def get_absolute_range(self, arg: _ArgE) -> tuple[int, int]: ...

def get_rank(expr): ...
def get_shape(expr): ...
def nest_permutation(expr): ...
