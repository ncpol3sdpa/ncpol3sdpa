from .common import MatrixCommon as MatrixCommon
from .exceptions import NonSquareMatrixError as NonSquareMatrixError
from .matrixbase import MatrixBase as MatrixBase
from _typeshed import Incomplete
from sympy.core.basic import Basic as Basic
from sympy.core.symbol import Dummy as Dummy

__doctest_requires__: Incomplete

class MatrixDeterminant(MatrixCommon):
    def adjugate(self, method: str = 'berkowitz'): ...
    def charpoly(self, x: str = 'lambda', simplify=...): ...
    def cofactor(self, i, j, method: str = 'berkowitz'): ...
    def cofactor_matrix(self, method: str = 'berkowitz'): ...
    def det(self, method: str = 'bareiss', iszerofunc: Incomplete | None = None): ...
    def per(self): ...
    def minor(self, i, j, method: str = 'berkowitz'): ...
    def minor_submatrix(self, i, j): ...

class MatrixReductions(MatrixDeterminant):
    def echelon_form(self, iszerofunc=..., simplify: bool = False, with_pivots: bool = False): ...
    @property
    def is_echelon(self): ...
    def rank(self, iszerofunc=..., simplify: bool = False): ...
    def rref_rhs(self, rhs): ...
    def rref(self, iszerofunc=..., simplify: bool = False, pivots: bool = True, normalize_last: bool = True): ...
    def elementary_col_op(self, op: str = 'n->kn', col: Incomplete | None = None, k: Incomplete | None = None, col1: Incomplete | None = None, col2: Incomplete | None = None): ...
    def elementary_row_op(self, op: str = 'n->kn', row: Incomplete | None = None, k: Incomplete | None = None, row1: Incomplete | None = None, row2: Incomplete | None = None): ...

class MatrixSubspaces(MatrixReductions):
    def columnspace(self, simplify: bool = False): ...
    def nullspace(self, simplify: bool = False, iszerofunc=...): ...
    def rowspace(self, simplify: bool = False): ...
    def orthogonalize(cls, *vecs, **kwargs): ...
    orthogonalize: Incomplete

class MatrixEigen(MatrixSubspaces):
    def eigenvals(self, error_when_incomplete: bool = True, **flags): ...
    def eigenvects(self, error_when_incomplete: bool = True, iszerofunc=..., **flags): ...
    def is_diagonalizable(self, reals_only: bool = False, **kwargs): ...
    def diagonalize(self, reals_only: bool = False, sort: bool = False, normalize: bool = False): ...
    def bidiagonalize(self, upper: bool = True): ...
    def bidiagonal_decomposition(self, upper: bool = True): ...
    @property
    def is_positive_definite(self): ...
    @property
    def is_positive_semidefinite(self): ...
    @property
    def is_negative_definite(self): ...
    @property
    def is_negative_semidefinite(self): ...
    @property
    def is_indefinite(self): ...
    def jordan_form(self, calc_transform: bool = True, **kwargs): ...
    def left_eigenvects(self, **flags): ...
    def singular_values(self): ...

class MatrixCalculus(MatrixCommon):
    def diff(self, *args, evaluate: bool = True, **kwargs): ...
    def integrate(self, *args, **kwargs): ...
    def jacobian(self, X): ...
    def limit(self, *args): ...

class MatrixDeprecated(MatrixCommon):
    def berkowitz_charpoly(self, x=..., simplify=...): ...
    def berkowitz_det(self): ...
    def berkowitz_eigenvals(self, **flags): ...
    def berkowitz_minors(self): ...
    def berkowitz(self): ...
    def cofactorMatrix(self, method: str = 'berkowitz'): ...
    def det_bareis(self): ...
    def det_LU_decomposition(self): ...
    def jordan_cell(self, eigenval, n): ...
    def jordan_cells(self, calc_transformation: bool = True): ...
    def minorEntry(self, i, j, method: str = 'berkowitz'): ...
    def minorMatrix(self, i, j): ...
    def permuteBkwd(self, perm): ...
    def permuteFwd(self, perm): ...
