from .exceptions import MatrixError as MatrixError, NonInvertibleMatrixError as NonInvertibleMatrixError, NonPositiveDefiniteMatrixError as NonPositiveDefiniteMatrixError, NonSquareMatrixError as NonSquareMatrixError, ShapeError as ShapeError
from _typeshed import Incomplete
from sympy.assumptions.refine import refine as refine
from sympy.core import Add as Add, SympifyError as SympifyError
from sympy.core.basic import Atom as Atom
from sympy.core.decorators import call_highest_priority as call_highest_priority
from sympy.core.logic import FuzzyBool as FuzzyBool, fuzzy_and as fuzzy_and
from sympy.core.mod import Mod as Mod
from sympy.core.numbers import Integer as Integer
from sympy.core.singleton import S as S
from sympy.core.symbol import Symbol as Symbol
from sympy.core.sympify import sympify as sympify
from sympy.functions.elementary.complexes import Abs as Abs, im as im, re as re
from sympy.polys.polytools import Poly as Poly
from sympy.tensor.array import NDimArray as NDimArray
from sympy.utilities.exceptions import sympy_deprecation_warning as sympy_deprecation_warning
from sympy.utilities.iterables import flatten as flatten, is_sequence as is_sequence
from sympy.utilities.misc import as_int as as_int, filldedent as filldedent

class _MatrixDeprecatedMeta(type):
    def __instancecheck__(cls, instance): ...

class MatrixRequired(metaclass=_MatrixDeprecatedMeta):
    rows: int
    cols: int
    def __init_subclass__(cls, **kwargs) -> None: ...
    def __eq__(self, other): ...
    def __getitem__(self, key) -> None: ...
    def __len__(self) -> int: ...
    @property
    def shape(self) -> None: ...

class MatrixShaping(MatrixRequired):
    def col_del(self, col): ...
    def col_insert(self, pos, other): ...
    def col_join(self, other): ...
    def col(self, j): ...
    def extract(self, rowsList, colsList): ...
    def get_diag_blocks(self): ...
    @classmethod
    def hstack(cls, *args): ...
    def reshape(self, rows, cols): ...
    def row_del(self, row): ...
    def row_insert(self, pos, other): ...
    def row_join(self, other): ...
    def diagonal(self, k: int = 0): ...
    def row(self, i): ...
    @property
    def shape(self): ...
    def todok(self): ...
    def tolist(self): ...
    def todod(M): ...
    def vec(self): ...
    def vech(self, diagonal: bool = True, check_symmetry: bool = True): ...
    @classmethod
    def vstack(cls, *args): ...

class MatrixSpecial(MatrixRequired):
    @classmethod
    def diag(kls, *args, strict: bool = False, unpack: bool = True, rows: Incomplete | None = None, cols: Incomplete | None = None, **kwargs): ...
    @classmethod
    def eye(kls, rows, cols: Incomplete | None = None, **kwargs): ...
    @classmethod
    def jordan_block(kls, size: Incomplete | None = None, eigenvalue: Incomplete | None = None, *, band: str = 'upper', **kwargs): ...
    @classmethod
    def ones(kls, rows, cols: Incomplete | None = None, **kwargs): ...
    @classmethod
    def zeros(kls, rows, cols: Incomplete | None = None, **kwargs): ...
    @classmethod
    def companion(kls, poly): ...
    @classmethod
    def wilkinson(kls, n, **kwargs): ...

class MatrixProperties(MatrixRequired):
    def atoms(self, *types): ...
    @property
    def free_symbols(self): ...
    def has(self, *patterns): ...
    def is_anti_symmetric(self, simplify: bool = True): ...
    def is_diagonal(self): ...
    @property
    def is_weakly_diagonally_dominant(self): ...
    @property
    def is_strongly_diagonally_dominant(self): ...
    @property
    def is_hermitian(self): ...
    @property
    def is_Identity(self) -> FuzzyBool: ...
    @property
    def is_lower_hessenberg(self): ...
    @property
    def is_lower(self): ...
    @property
    def is_square(self): ...
    def is_symbolic(self): ...
    def is_symmetric(self, simplify: bool = True): ...
    @property
    def is_upper_hessenberg(self): ...
    @property
    def is_upper(self): ...
    @property
    def is_zero_matrix(self): ...
    def values(self): ...

class MatrixOperations(MatrixRequired):
    def adjoint(self): ...
    def applyfunc(self, f): ...
    def as_real_imag(self, deep: bool = True, **hints): ...
    def conjugate(self): ...
    def doit(self, **hints): ...
    def evalf(self, n: int = 15, subs: Incomplete | None = None, maxn: int = 100, chop: bool = False, strict: bool = False, quad: Incomplete | None = None, verbose: bool = False): ...
    def expand(self, deep: bool = True, modulus: Incomplete | None = None, power_base: bool = True, power_exp: bool = True, mul: bool = True, log: bool = True, multinomial: bool = True, basic: bool = True, **hints): ...
    @property
    def H(self): ...
    def permute(self, perm, orientation: str = 'rows', direction: str = 'forward'): ...
    def permute_cols(self, swaps, direction: str = 'forward'): ...
    def permute_rows(self, swaps, direction: str = 'forward'): ...
    def refine(self, assumptions: bool = True): ...
    def replace(self, F, G, map: bool = False, simultaneous: bool = True, exact: Incomplete | None = None): ...
    def rot90(self, k: int = 1): ...
    def simplify(self, **kwargs): ...
    def subs(self, *args, **kwargs): ...
    def trace(self): ...
    def transpose(self): ...
    @property
    def T(self): ...
    @property
    def C(self): ...
    def n(self, *args, **kwargs): ...
    def xreplace(self, rule): ...
    def upper_triangular(self, k: int = 0): ...
    def lower_triangular(self, k: int = 0): ...

class MatrixArithmetic(MatrixRequired):
    def __abs__(self): ...
    def __add__(self, other): ...
    def __truediv__(self, other): ...
    def __matmul__(self, other): ...
    def __mod__(self, other): ...
    def __mul__(self, other): ...
    def multiply(self, other, dotprodsimp: Incomplete | None = None): ...
    def multiply_elementwise(self, other): ...
    def __neg__(self): ...
    def __pow__(self, exp): ...
    def pow(self, exp, method: Incomplete | None = None): ...
    def __radd__(self, other): ...
    def __rmatmul__(self, other): ...
    def __rmul__(self, other): ...
    def rmultiply(self, other, dotprodsimp: Incomplete | None = None): ...
    def __rsub__(self, a): ...
    def __sub__(self, a): ...

class MatrixCommon(MatrixArithmetic, MatrixOperations, MatrixProperties, MatrixSpecial, MatrixShaping): ...

class _MinimalMatrix:
    is_MatrixLike: bool
    zero: Incomplete
    one: Incomplete
    is_Matrix: bool
    is_MatrixExpr: bool
    mat: Incomplete
    def __init__(self, rows, cols: Incomplete | None = None, mat: Incomplete | None = None, copy: bool = False) -> None: ...
    def __getitem__(self, key): ...
    def __eq__(self, other): ...
    def __len__(self) -> int: ...
    @property
    def shape(self): ...

class _CastableMatrix:
    def as_mutable(self): ...
    def as_immutable(self): ...

class _MatrixWrapper:
    is_Matrix: bool
    is_MatrixLike: bool
    mat: Incomplete
    shape: Incomplete
    def __init__(self, mat, shape) -> None: ...
    def __getitem__(self, key): ...
    def __iter__(self): ...

def a2idx(j, n: Incomplete | None = None): ...
def classof(A, B): ...
