from _typeshed import Incomplete
from sympy.core.basic import Basic as Basic
from sympy.core.cache import cacheit as cacheit
from sympy.core.function import Lambda as Lambda, PoleError as PoleError
from sympy.core.numbers import I as I, nan as nan, oo as oo
from sympy.core.relational import Eq as Eq, Ne as Ne
from sympy.core.singleton import S as S
from sympy.core.symbol import Dummy as Dummy, symbols as symbols
from sympy.core.sympify import sympify as sympify
from sympy.functions.combinatorial.factorials import factorial as factorial
from sympy.functions.elementary.exponential import exp as exp
from sympy.functions.elementary.piecewise import Piecewise as Piecewise
from sympy.functions.special.delta_functions import DiracDelta as DiracDelta
from sympy.integrals.integrals import Integral as Integral, integrate as integrate
from sympy.logic.boolalg import And as And, Or as Or
from sympy.polys.polyerrors import PolynomialError as PolynomialError
from sympy.polys.polytools import poly as poly
from sympy.series.series import series as series
from sympy.sets.sets import FiniteSet as FiniteSet, Intersection as Intersection, Interval as Interval, Union as Union
from sympy.solvers.inequalities import reduce_rational_inequalities as reduce_rational_inequalities
from sympy.solvers.solveset import solveset as solveset
from sympy.stats.rv import ConditionalDomain as ConditionalDomain, Distribution as Distribution, NamedArgsMixin as NamedArgsMixin, PSpace as PSpace, ProductDomain as ProductDomain, RandomDomain as RandomDomain, SingleDomain as SingleDomain, SinglePSpace as SinglePSpace, is_random as is_random, random_symbols as random_symbols

class ContinuousDomain(RandomDomain):
    is_Continuous: bool
    def as_boolean(self) -> None: ...

class SingleContinuousDomain(ContinuousDomain, SingleDomain):
    def compute_expectation(self, expr, variables: Incomplete | None = None, **kwargs): ...
    def as_boolean(self): ...

class ProductContinuousDomain(ProductDomain, ContinuousDomain):
    def compute_expectation(self, expr, variables: Incomplete | None = None, **kwargs): ...
    def as_boolean(self): ...

class ConditionalContinuousDomain(ContinuousDomain, ConditionalDomain):
    def compute_expectation(self, expr, variables: Incomplete | None = None, **kwargs): ...
    def as_boolean(self): ...
    @property
    def set(self): ...

class ContinuousDistribution(Distribution):
    def __call__(self, *args): ...

class SingleContinuousDistribution(ContinuousDistribution, NamedArgsMixin):
    set: Incomplete
    def __new__(cls, *args): ...
    @staticmethod
    def check(*args) -> None: ...
    def compute_cdf(self, **kwargs): ...
    def cdf(self, x, **kwargs): ...
    def compute_characteristic_function(self, **kwargs): ...
    def characteristic_function(self, t, **kwargs): ...
    def compute_moment_generating_function(self, **kwargs): ...
    def moment_generating_function(self, t, **kwargs): ...
    def expectation(self, expr, var, evaluate: bool = True, **kwargs): ...
    def compute_quantile(self, **kwargs): ...
    def quantile(self, x, **kwargs): ...

class ContinuousPSpace(PSpace):
    is_Continuous: bool
    is_real: bool
    @property
    def pdf(self): ...
    def compute_expectation(self, expr, rvs: Incomplete | None = None, evaluate: bool = False, **kwargs): ...
    def compute_density(self, expr, **kwargs): ...
    def compute_cdf(self, expr, **kwargs): ...
    def compute_characteristic_function(self, expr, **kwargs): ...
    def compute_moment_generating_function(self, expr, **kwargs): ...
    def compute_quantile(self, expr, **kwargs): ...
    def probability(self, condition, **kwargs): ...
    def where(self, condition): ...
    def conditional_space(self, condition, normalize: bool = True, **kwargs): ...

class SingleContinuousPSpace(ContinuousPSpace, SinglePSpace):
    @property
    def set(self): ...
    @property
    def domain(self): ...
    def sample(self, size=(), library: str = 'scipy', seed: Incomplete | None = None): ...
    def compute_expectation(self, expr, rvs: Incomplete | None = None, evaluate: bool = False, **kwargs): ...
    def compute_cdf(self, expr, **kwargs): ...
    def compute_characteristic_function(self, expr, **kwargs): ...
    def compute_moment_generating_function(self, expr, **kwargs): ...
    def compute_density(self, expr, **kwargs): ...
    def compute_quantile(self, expr, **kwargs): ...

def reduce_rational_inequalities_wrap(condition, var): ...
