from _typeshed import Incomplete
from sympy.core.add import Add as Add
from sympy.core.basic import Basic as Basic
from sympy.core.containers import Tuple as Tuple
from sympy.core.expr import Expr as Expr
from sympy.core.function import Function as Function, Lambda as Lambda
from sympy.core.logic import fuzzy_and as fuzzy_and
from sympy.core.mul import Mul as Mul
from sympy.core.relational import Eq as Eq, Ne as Ne, Relational as Relational
from sympy.core.singleton import S as S
from sympy.core.symbol import Dummy as Dummy, Symbol as Symbol
from sympy.core.sympify import sympify as sympify
from sympy.external import import_module as import_module
from sympy.functions.special.delta_functions import DiracDelta as DiracDelta
from sympy.functions.special.tensor_functions import KroneckerDelta as KroneckerDelta
from sympy.logic.boolalg import And as And, Or as Or
from sympy.matrices.expressions.matexpr import MatrixSymbol as MatrixSymbol
from sympy.sets.sets import FiniteSet as FiniteSet, Intersection as Intersection, ProductSet as ProductSet
from sympy.solvers.solveset import solveset as solveset
from sympy.tensor.indexed import Indexed as Indexed
from sympy.utilities.decorator import doctest_depends_on as doctest_depends_on
from sympy.utilities.exceptions import sympy_deprecation_warning as sympy_deprecation_warning
from sympy.utilities.iterables import iterable as iterable
from sympy.utilities.lambdify import lambdify as lambdify

__doctest_requires__: Incomplete
x: Incomplete

def is_random(x): ...
def _(x): ...

class RandomDomain(Basic):
    is_ProductDomain: bool
    is_Finite: bool
    is_Continuous: bool
    is_Discrete: bool
    def __new__(cls, symbols, *args): ...
    @property
    def symbols(self): ...
    @property
    def set(self): ...
    def __contains__(self, other) -> bool: ...
    def compute_expectation(self, expr) -> None: ...

class SingleDomain(RandomDomain):
    def __new__(cls, symbol, set): ...
    @property
    def symbol(self): ...
    @property
    def symbols(self): ...
    def __contains__(self, other) -> bool: ...

class MatrixDomain(RandomDomain):
    def __new__(cls, symbol, set): ...
    @property
    def symbol(self): ...
    @property
    def symbols(self): ...

class ConditionalDomain(RandomDomain):
    def __new__(cls, fulldomain, condition): ...
    @property
    def symbols(self): ...
    @property
    def fulldomain(self): ...
    @property
    def condition(self): ...
    @property
    def set(self) -> None: ...
    def as_boolean(self): ...

class PSpace(Basic):
    is_Finite: bool
    is_Continuous: bool
    is_Discrete: bool
    is_real: bool
    @property
    def domain(self): ...
    @property
    def density(self): ...
    @property
    def values(self): ...
    @property
    def symbols(self): ...
    def where(self, condition) -> None: ...
    def compute_density(self, expr) -> None: ...
    def sample(self, size=(), library: str = 'scipy', seed: Incomplete | None = None) -> None: ...
    def probability(self, condition) -> None: ...
    def compute_expectation(self, expr) -> None: ...

class SinglePSpace(PSpace):
    def __new__(cls, s, distribution): ...
    @property
    def value(self): ...
    @property
    def symbol(self): ...
    @property
    def distribution(self): ...
    @property
    def pdf(self): ...

class RandomSymbol(Expr):
    def __new__(cls, symbol, pspace: Incomplete | None = None): ...
    is_finite: bool
    is_symbol: bool
    is_Atom: bool
    pspace: Incomplete
    symbol: Incomplete
    name: Incomplete
    @property
    def is_commutative(self): ...
    @property
    def free_symbols(self): ...

class RandomIndexedSymbol(RandomSymbol):
    def __new__(cls, idx_obj, pspace: Incomplete | None = None): ...
    symbol: Incomplete
    name: Incomplete
    @property
    def key(self): ...
    @property
    def free_symbols(self): ...
    @property
    def pspace(self): ...

class RandomMatrixSymbol(RandomSymbol, MatrixSymbol):
    def __new__(cls, symbol, n, m, pspace: Incomplete | None = None): ...
    symbol: Incomplete
    pspace: Incomplete

class ProductPSpace(PSpace): ...

class IndependentProductPSpace(ProductPSpace):
    def __new__(cls, *spaces): ...
    @property
    def pdf(self): ...
    @property
    def rs_space_dict(self): ...
    @property
    def symbols(self): ...
    @property
    def spaces(self): ...
    @property
    def values(self): ...
    def compute_expectation(self, expr, rvs: Incomplete | None = None, evaluate: bool = False, **kwargs): ...
    @property
    def domain(self): ...
    @property
    def density(self) -> None: ...
    def sample(self, size=(), library: str = 'scipy', seed: Incomplete | None = None): ...
    def probability(self, condition, **kwargs): ...
    def compute_density(self, expr, **kwargs): ...
    def compute_cdf(self, expr, **kwargs) -> None: ...
    def conditional_space(self, condition, normalize: bool = True, **kwargs): ...

class ProductDomain(RandomDomain):
    is_ProductDomain: bool
    def __new__(cls, *domains): ...
    @property
    def sym_domain_dict(self): ...
    @property
    def symbols(self): ...
    @property
    def domains(self): ...
    @property
    def set(self): ...
    def __contains__(self, other) -> bool: ...
    def as_boolean(self): ...

def random_symbols(expr): ...
def pspace(expr): ...
def sumsets(sets): ...
def rs_swap(a, b): ...
def given(expr, condition: Incomplete | None = None, **kwargs): ...
def expectation(expr, condition: Incomplete | None = None, numsamples: Incomplete | None = None, evaluate: bool = True, **kwargs): ...
def probability(condition, given_condition: Incomplete | None = None, numsamples: Incomplete | None = None, evaluate: bool = True, **kwargs): ...

class Density(Basic):
    expr: Incomplete
    def __new__(cls, expr, condition: Incomplete | None = None): ...
    @property
    def condition(self): ...
    def doit(self, evaluate: bool = True, **kwargs): ...

def density(expr, condition: Incomplete | None = None, evaluate: bool = True, numsamples: Incomplete | None = None, **kwargs): ...
def cdf(expr, condition: Incomplete | None = None, evaluate: bool = True, **kwargs): ...
def characteristic_function(expr, condition: Incomplete | None = None, evaluate: bool = True, **kwargs): ...
def moment_generating_function(expr, condition: Incomplete | None = None, evaluate: bool = True, **kwargs): ...
def where(condition, given_condition: Incomplete | None = None, **kwargs): ...
def sample(expr, condition: Incomplete | None = None, size=(), library: str = 'scipy', numsamples: int = 1, seed: Incomplete | None = None, **kwargs): ...
def quantile(expr, evaluate: bool = True, **kwargs): ...
def sample_iter(expr, condition: Incomplete | None = None, size=(), library: str = 'scipy', numsamples=..., seed: Incomplete | None = None, **kwargs): ...
def sample_iter_lambdify(expr, condition: Incomplete | None = None, size=(), numsamples=..., seed: Incomplete | None = None, **kwargs): ...
def sample_iter_subs(expr, condition: Incomplete | None = None, size=(), numsamples=..., seed: Incomplete | None = None, **kwargs): ...
def sampling_P(condition, given_condition: Incomplete | None = None, library: str = 'scipy', numsamples: int = 1, evalf: bool = True, seed: Incomplete | None = None, **kwargs): ...
def sampling_E(expr, given_condition: Incomplete | None = None, library: str = 'scipy', numsamples: int = 1, evalf: bool = True, seed: Incomplete | None = None, **kwargs): ...
def sampling_density(expr, given_condition: Incomplete | None = None, library: str = 'scipy', numsamples: int = 1, seed: Incomplete | None = None, **kwargs): ...
def dependent(a, b): ...
def independent(a, b): ...
def pspace_independent(a, b): ...
def rv_subs(expr, symbols: Incomplete | None = None): ...

class NamedArgsMixin:
    def __getattr__(self, attr): ...

class Distribution(Basic):
    def sample(self, size=(), library: str = 'scipy', seed: Incomplete | None = None): ...

def sample_stochastic_process(process): ...
