from _typeshed import Incomplete
from collections.abc import Generator
from sympy.core.basic import Basic
from sympy.core.function import Lambda
from sympy.core.numbers import Integer
from sympy.core.symbol import Symbol
from sympy.logic.boolalg import Boolean
from sympy.matrices.immutable import ImmutableMatrix
from sympy.sets.conditionset import ConditionSet
from sympy.sets.fancysets import Range
from sympy.sets.sets import FiniteSet

__all__ = ['StochasticProcess', 'DiscreteTimeStochasticProcess', 'DiscreteMarkovChain', 'TransitionMatrixOf', 'StochasticStateSpaceOf', 'GeneratorMatrixOf', 'ContinuousMarkovChain', 'BernoulliProcess', 'PoissonProcess', 'WienerProcess', 'GammaProcess']

class StochasticProcess(Basic):
    index_set: Incomplete
    def __new__(cls, sym, state_space=..., **kwargs): ...
    @property
    def symbol(self): ...
    @property
    def state_space(self) -> FiniteSet | Range: ...
    def distribution(self, key: Incomplete | None = None): ...
    def density(self, x): ...
    def __call__(self, time) -> None: ...
    def __getitem__(self, time) -> None: ...
    def probability(self, condition) -> None: ...
    def joint_distribution(self, *args): ...
    def expectation(self, condition, given_condition) -> None: ...
    def sample(self) -> None: ...

class DiscreteTimeStochasticProcess(StochasticProcess):
    def __getitem__(self, time): ...

class ContinuousTimeStochasticProcess(StochasticProcess):
    def __call__(self, time): ...

class TransitionMatrixOf(Boolean):
    def __new__(cls, process, matrix): ...
    process: Incomplete
    matrix: Incomplete

class GeneratorMatrixOf(TransitionMatrixOf):
    def __new__(cls, process, matrix): ...

class StochasticStateSpaceOf(Boolean):
    def __new__(cls, process, state_space): ...
    process: Incomplete
    state_index: Incomplete

class MarkovProcess(StochasticProcess):
    @property
    def number_of_states(self) -> Integer | Symbol: ...
    def replace_with_index(self, condition): ...
    def probability(self, condition, given_condition: Incomplete | None = None, evaluate: bool = True, **kwargs): ...
    def expectation(self, expr, condition: Incomplete | None = None, evaluate: bool = True, **kwargs): ...

class DiscreteMarkovChain(DiscreteTimeStochasticProcess, MarkovProcess):
    index_set: Incomplete
    def __new__(cls, sym, state_space: Incomplete | None = None, trans_probs: Incomplete | None = None): ...
    @property
    def transition_probabilities(self): ...
    def communication_classes(self) -> list[tuple[list[Basic], Boolean, Integer]]: ...
    def fundamental_matrix(self): ...
    def absorbing_probabilities(self): ...
    def absorbing_probabilites(self): ...
    def is_regular(self): ...
    def is_ergodic(self): ...
    def is_absorbing_state(self, state): ...
    def is_absorbing_chain(self): ...
    def stationary_distribution(self, condition_set: bool = False) -> ImmutableMatrix | ConditionSet | Lambda: ...
    def fixed_row_vector(self): ...
    @property
    def limiting_distribution(self): ...
    def decompose(self) -> tuple[list[Basic], ImmutableMatrix, ImmutableMatrix, ImmutableMatrix]: ...
    def canonical_form(self) -> tuple[list[Basic], ImmutableMatrix]: ...
    def sample(self) -> Generator[Incomplete]: ...

class ContinuousMarkovChain(ContinuousTimeStochasticProcess, MarkovProcess):
    index_set: Incomplete
    def __new__(cls, sym, state_space: Incomplete | None = None, gen_mat: Incomplete | None = None): ...
    @property
    def generator_matrix(self): ...
    def transition_probabilities(self, gen_mat: Incomplete | None = None): ...
    def limiting_distribution(self): ...

class BernoulliProcess(DiscreteTimeStochasticProcess):
    index_set: Incomplete
    def __new__(cls, sym, p, success: int = 1, failure: int = 0): ...
    @property
    def symbol(self): ...
    @property
    def p(self): ...
    @property
    def success(self): ...
    @property
    def failure(self): ...
    @property
    def state_space(self): ...
    def distribution(self, key: Incomplete | None = None): ...
    def simple_rv(self, rv): ...
    def expectation(self, expr, condition: Incomplete | None = None, evaluate: bool = True, **kwargs): ...
    def probability(self, condition, given_condition: Incomplete | None = None, evaluate: bool = True, **kwargs): ...
    def density(self, x): ...

class _SubstituteRV: ...

class CountingProcess(ContinuousTimeStochasticProcess):
    index_set: Incomplete
    @property
    def symbol(self): ...
    def expectation(self, expr, condition: Incomplete | None = None, evaluate: bool = True, **kwargs): ...
    def probability(self, condition, given_condition: Incomplete | None = None, evaluate: bool = True, **kwargs): ...

class PoissonProcess(CountingProcess):
    def __new__(cls, sym, lamda): ...
    @property
    def lamda(self): ...
    @property
    def state_space(self): ...
    def distribution(self, key): ...
    def density(self, x): ...
    def simple_rv(self, rv): ...
    def __add__(self, other): ...
    def split(self, l1, l2): ...

class WienerProcess(CountingProcess):
    def __new__(cls, sym): ...
    @property
    def state_space(self): ...
    def distribution(self, key): ...
    def density(self, x): ...
    def simple_rv(self, rv): ...

class GammaProcess(CountingProcess):
    def __new__(cls, sym, lamda, gamma): ...
    @property
    def lamda(self): ...
    @property
    def gamma(self): ...
    @property
    def state_space(self): ...
    def distribution(self, key): ...
    def density(self, x): ...
    def simple_rv(self, rv): ...
