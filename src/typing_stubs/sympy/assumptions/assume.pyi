from _typeshed import Incomplete
from collections.abc import Generator
from sympy.core.symbol import Str as Str
from sympy.logic.boolalg import Boolean as Boolean, false as false, true as true
from sympy.multipledispatch.dispatcher import Dispatcher as Dispatcher, str_signature as str_signature
from sympy.utilities.exceptions import sympy_deprecation_warning as sympy_deprecation_warning
from sympy.utilities.iterables import is_sequence as is_sequence
from sympy.utilities.source import get_class as get_class

class AssumptionsContext(set):
    def add(self, *assumptions) -> None: ...

global_assumptions: Incomplete

class AppliedPredicate(Boolean):
    def __new__(cls, predicate, *args): ...
    @property
    def arg(self): ...
    @property
    def function(self): ...
    @property
    def arguments(self): ...
    @property
    def binary_symbols(self): ...

class PredicateMeta(type):
    def __new__(cls, clsname, bases, dct): ...
    @property
    def __doc__(cls): ...

class Predicate(Boolean, metaclass=PredicateMeta):
    is_Atom: bool
    def __new__(cls, *args, **kwargs): ...
    @property
    def name(self): ...
    @classmethod
    def register(cls, *types, **kwargs): ...
    @classmethod
    def register_many(cls, *types, **kwargs): ...
    def __call__(self, *args): ...
    def eval(self, args, assumptions: bool = True): ...

class UndefinedPredicate(Predicate):
    handler: Incomplete
    def __new__(cls, name, handlers: Incomplete | None = None): ...
    @property
    def name(self): ...
    def __getnewargs__(self): ...
    def __call__(self, expr): ...
    def add_handler(self, handler) -> None: ...
    def remove_handler(self, handler) -> None: ...
    def eval(self, args, assumptions: bool = True): ...

def assuming(*assumptions) -> Generator[None]: ...
