from _typeshed import Incomplete
from sympy.core.basic import Basic as Basic
from sympy.core.containers import Tuple as Tuple, TupleKind as TupleKind
from sympy.core.decorators import sympify_method_args as sympify_method_args, sympify_return as sympify_return
from sympy.core.evalf import EvalfMixin as EvalfMixin
from sympy.core.expr import Expr as Expr
from sympy.core.function import Lambda as Lambda
from sympy.core.kind import Kind as Kind, NumberKind as NumberKind, UndefinedKind as UndefinedKind
from sympy.core.logic import FuzzyBool as FuzzyBool, fuzzy_and as fuzzy_and, fuzzy_bool as fuzzy_bool, fuzzy_not as fuzzy_not, fuzzy_or as fuzzy_or
from sympy.core.numbers import Float as Float, Integer as Integer
from sympy.core.operations import LatticeOp as LatticeOp
from sympy.core.parameters import global_parameters as global_parameters
from sympy.core.relational import Eq as Eq, Ne as Ne, is_lt as is_lt
from sympy.core.singleton import S as S, Singleton as Singleton
from sympy.core.sorting import ordered as ordered
from sympy.core.symbol import Dummy as Dummy, Symbol as Symbol, symbols as symbols, uniquely_named_symbol as uniquely_named_symbol
from sympy.core.sympify import sympify as sympify
from sympy.functions.elementary.exponential import exp as exp, log as log
from sympy.functions.elementary.miscellaneous import Max as Max, Min as Min
from sympy.logic.boolalg import And as And, Not as Not, Or as Or, Xor as Xor, false as false, true as true
from sympy.utilities.decorator import deprecated as deprecated
from sympy.utilities.exceptions import sympy_deprecation_warning as sympy_deprecation_warning
from sympy.utilities.iterables import iproduct as iproduct, iterable as iterable, roundrobin as roundrobin, sift as sift, subsets as subsets
from sympy.utilities.misc import filldedent as filldedent, func_name as func_name
from typing import Any, Callable

tfn: Incomplete

class Set(Basic, EvalfMixin):
    is_number: bool
    is_iterable: bool
    is_interval: bool
    is_FiniteSet: bool
    is_Interval: bool
    is_ProductSet: bool
    is_Union: bool
    is_Intersection: FuzzyBool
    is_UniversalSet: FuzzyBool
    is_Complement: FuzzyBool
    is_ComplexRegion: bool
    is_empty: FuzzyBool
    is_finite_set: FuzzyBool
    @property
    def is_EmptySet(self) -> None: ...
    def union(self, other): ...
    def intersect(self, other): ...
    def intersection(self, other): ...
    def is_disjoint(self, other): ...
    def isdisjoint(self, other): ...
    def complement(self, universe): ...
    def symmetric_difference(self, other): ...
    @property
    def inf(self): ...
    @property
    def sup(self): ...
    def contains(self, other): ...
    def is_subset(self, other): ...
    def issubset(self, other): ...
    def is_proper_subset(self, other): ...
    def is_superset(self, other): ...
    def issuperset(self, other): ...
    def is_proper_superset(self, other): ...
    def powerset(self): ...
    @property
    def measure(self): ...
    @property
    def kind(self): ...
    @property
    def boundary(self): ...
    @property
    def is_open(self): ...
    @property
    def is_closed(self): ...
    @property
    def closure(self): ...
    @property
    def interior(self): ...
    def __add__(self, other): ...
    def __or__(self, other): ...
    def __and__(self, other): ...
    def __mul__(self, other): ...
    def __xor__(self, other): ...
    def __pow__(self, exp): ...
    def __sub__(self, other): ...
    def __contains__(self, other) -> bool: ...

class ProductSet(Set):
    is_ProductSet: bool
    def __new__(cls, *sets, **assumptions): ...
    @property
    def sets(self): ...
    def flatten(self): ...
    def as_relational(self, *symbols): ...
    @property
    def is_iterable(self): ...
    def __iter__(self): ...
    @property
    def is_empty(self): ...
    @property
    def is_finite_set(self): ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...

class Interval(Set):
    is_Interval: bool
    def __new__(cls, start, end, left_open: bool = False, right_open: bool = False): ...
    @property
    def start(self): ...
    @property
    def end(self): ...
    @property
    def left_open(self): ...
    @property
    def right_open(self): ...
    @classmethod
    def open(cls, a, b): ...
    @classmethod
    def Lopen(cls, a, b): ...
    @classmethod
    def Ropen(cls, a, b): ...
    @property
    def left(self): ...
    @property
    def right(self): ...
    @property
    def is_empty(self): ...
    @property
    def is_finite_set(self): ...
    def as_relational(self, x): ...
    def to_mpi(self, prec: int = 53): ...
    @property
    def is_left_unbounded(self): ...
    @property
    def is_right_unbounded(self): ...

class Union(Set, LatticeOp):
    is_Union: bool
    @property
    def identity(self): ...
    @property
    def zero(self): ...
    def __new__(cls, *args, **kwargs): ...
    @property
    def args(self): ...
    @property
    def is_empty(self): ...
    @property
    def is_finite_set(self): ...
    def is_subset(self, other): ...
    def as_relational(self, symbol): ...
    @property
    def is_iterable(self): ...
    def __iter__(self): ...

class Intersection(Set, LatticeOp):
    is_Intersection: bool
    @property
    def identity(self): ...
    @property
    def zero(self): ...
    def __new__(cls, *args, evaluate: Incomplete | None = None): ...
    @property
    def args(self): ...
    @property
    def is_iterable(self): ...
    @property
    def is_finite_set(self): ...
    def __iter__(self): ...
    def as_relational(self, symbol): ...

class Complement(Set):
    is_Complement: bool
    def __new__(cls, a, b, evaluate: bool = True): ...
    @staticmethod
    def reduce(A, B): ...
    def as_relational(self, symbol): ...
    @property
    def is_iterable(self): ...
    @property
    def is_finite_set(self): ...
    def __iter__(self): ...

class EmptySet(Set, metaclass=Singleton):
    is_empty: bool
    is_finite_set: bool
    is_FiniteSet: bool
    @property
    def is_EmptySet(self): ...
    def as_relational(self, symbol): ...
    def __len__(self) -> int: ...
    def __iter__(self): ...

class UniversalSet(Set, metaclass=Singleton):
    is_UniversalSet: bool
    is_empty: bool
    is_finite_set: bool
    def as_relational(self, symbol): ...

class FiniteSet(Set):
    is_FiniteSet: bool
    is_iterable: bool
    is_empty: bool
    is_finite_set: bool
    def __new__(cls, *args, **kwargs): ...
    def __iter__(self): ...
    @property
    def measure(self): ...
    def __len__(self) -> int: ...
    def as_relational(self, symbol): ...
    def compare(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...
    __hash__: Callable[[Basic], Any]

class SymmetricDifference(Set):
    is_SymmetricDifference: bool
    def __new__(cls, a, b, evaluate: bool = True): ...
    @staticmethod
    def reduce(A, B): ...
    def as_relational(self, symbol): ...
    @property
    def is_iterable(self): ...
    def __iter__(self): ...

class DisjointUnion(Set):
    def __new__(cls, *sets): ...
    @property
    def sets(self): ...
    @property
    def is_empty(self): ...
    @property
    def is_finite_set(self): ...
    @property
    def is_iterable(self): ...
    def __iter__(self): ...
    def __len__(self) -> int: ...

def imageset(*args): ...
def is_function_invertible_in_set(func, setv): ...
def simplify_union(args): ...
def simplify_intersection(args): ...
def set_add(x, y): ...
def set_sub(x, y): ...
def set_mul(x, y): ...
def set_div(x, y): ...
def set_pow(x, y): ...
def set_function(f, x): ...

class SetKind(Kind):
    def __new__(cls, element_kind: Incomplete | None = None): ...
