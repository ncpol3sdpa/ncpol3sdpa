from .sets import FiniteSet as FiniteSet, Interval as Interval, ProductSet as ProductSet, Set as Set, SetKind as SetKind, Union as Union, tfn as tfn
from _typeshed import Incomplete
from sympy.core.basic import Basic as Basic
from sympy.core.containers import Tuple as Tuple
from sympy.core.expr import Expr as Expr
from sympy.core.function import Lambda as Lambda
from sympy.core.intfunc import igcd as igcd
from sympy.core.kind import NumberKind as NumberKind
from sympy.core.logic import fuzzy_and as fuzzy_and, fuzzy_not as fuzzy_not, fuzzy_or as fuzzy_or
from sympy.core.mod import Mod as Mod
from sympy.core.numbers import Rational as Rational, oo as oo
from sympy.core.relational import Eq as Eq, is_eq as is_eq
from sympy.core.singleton import S as S, Singleton as Singleton
from sympy.core.symbol import Dummy as Dummy, Symbol as Symbol, symbols as symbols
from sympy.core.sympify import sympify as sympify
from sympy.functions.elementary.integers import ceiling as ceiling, floor as floor
from sympy.functions.elementary.trigonometric import cos as cos, sin as sin
from sympy.logic.boolalg import And as And, Or as Or
from sympy.utilities.misc import filldedent as filldedent

class Rationals(Set, metaclass=Singleton):
    is_iterable: bool
    is_empty: bool
    is_finite_set: bool
    def __iter__(self): ...

class Naturals(Set, metaclass=Singleton):
    is_iterable: bool
    is_empty: bool
    is_finite_set: bool
    def __iter__(self): ...
    def as_relational(self, x): ...

class Naturals0(Naturals): ...

class Integers(Set, metaclass=Singleton):
    is_iterable: bool
    is_empty: bool
    is_finite_set: bool
    def __iter__(self): ...
    def as_relational(self, x): ...

class Reals(Interval, metaclass=Singleton):
    @property
    def start(self): ...
    @property
    def end(self): ...
    @property
    def left_open(self): ...
    @property
    def right_open(self): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class ImageSet(Set):
    def __new__(cls, flambda, *sets): ...
    lamda: Incomplete
    base_sets: Incomplete
    @property
    def base_set(self): ...
    @property
    def base_pset(self): ...
    def __iter__(self): ...
    @property
    def is_iterable(self): ...
    def doit(self, **hints): ...

class Range(Set):
    def __new__(cls, *args): ...
    start: Incomplete
    stop: Incomplete
    step: Incomplete
    @property
    def reversed(self): ...
    def __iter__(self): ...
    @property
    def is_iterable(self): ...
    def __len__(self) -> int: ...
    @property
    def size(self): ...
    @property
    def is_finite_set(self): ...
    @property
    def is_empty(self): ...
    def __bool__(self) -> bool: ...
    def __getitem__(self, i): ...
    def as_relational(self, x): ...

def normalize_theta_set(theta): ...

class ComplexRegion(Set):
    is_ComplexRegion: bool
    def __new__(cls, sets, polar: bool = False): ...
    @property
    def sets(self): ...
    @property
    def psets(self): ...
    @property
    def a_interval(self): ...
    @property
    def b_interval(self): ...
    @classmethod
    def from_real(cls, sets): ...

class CartesianComplexRegion(ComplexRegion):
    polar: bool
    variables: Incomplete
    def __new__(cls, sets): ...
    @property
    def expr(self): ...

class PolarComplexRegion(ComplexRegion):
    polar: bool
    variables: Incomplete
    def __new__(cls, sets): ...
    @property
    def expr(self): ...

class Complexes(CartesianComplexRegion, metaclass=Singleton):
    is_empty: bool
    is_finite_set: bool
    @property
    def sets(self): ...
    def __new__(cls): ...
