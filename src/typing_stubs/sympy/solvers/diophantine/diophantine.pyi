from _typeshed import Incomplete
from collections.abc import Generator

__all__ = ['diophantine', 'classify_diop']

class DiophantineSolutionSet(set):
    symbols: Incomplete
    parameters: Incomplete
    def __init__(self, symbols_seq, parameters) -> None: ...
    def add(self, solution) -> None: ...
    def update(self, *solutions) -> None: ...
    def dict_iterator(self) -> Generator[Incomplete]: ...
    def subs(self, *args, **kwargs): ...
    def __call__(self, *args): ...

class DiophantineEquationType:
    name: str
    equation: Incomplete
    free_symbols: Incomplete
    coeff: Incomplete
    total_degree: Incomplete
    homogeneous: Incomplete
    homogeneous_order: Incomplete
    dimension: Incomplete
    def __init__(self, equation, free_symbols: Incomplete | None = None) -> None: ...
    def matches(self): ...
    @property
    def n_parameters(self): ...
    @property
    def parameters(self): ...
    def solve(self, parameters: Incomplete | None = None, limit: Incomplete | None = None) -> DiophantineSolutionSet: ...
    def pre_solve(self, parameters: Incomplete | None = None) -> None: ...

class Univariate(DiophantineEquationType):
    name: str
    def matches(self): ...
    def solve(self, parameters: Incomplete | None = None, limit: Incomplete | None = None): ...

class Linear(DiophantineEquationType):
    name: str
    def matches(self): ...
    def solve(self, parameters: Incomplete | None = None, limit: Incomplete | None = None): ...

class BinaryQuadratic(DiophantineEquationType):
    name: str
    def matches(self): ...
    def solve(self, parameters: Incomplete | None = None, limit: Incomplete | None = None) -> DiophantineSolutionSet: ...

class InhomogeneousTernaryQuadratic(DiophantineEquationType):
    name: str
    def matches(self): ...

class HomogeneousTernaryQuadraticNormal(DiophantineEquationType):
    name: str
    def matches(self): ...
    def solve(self, parameters: Incomplete | None = None, limit: Incomplete | None = None) -> DiophantineSolutionSet: ...

class HomogeneousTernaryQuadratic(DiophantineEquationType):
    name: str
    def matches(self): ...
    def solve(self, parameters: Incomplete | None = None, limit: Incomplete | None = None): ...

class InhomogeneousGeneralQuadratic(DiophantineEquationType):
    name: str
    def matches(self): ...

class HomogeneousGeneralQuadratic(DiophantineEquationType):
    name: str
    def matches(self): ...

class GeneralSumOfSquares(DiophantineEquationType):
    name: str
    def matches(self): ...
    def solve(self, parameters: Incomplete | None = None, limit: int = 1): ...

class GeneralPythagorean(DiophantineEquationType):
    name: str
    def matches(self): ...
    @property
    def n_parameters(self): ...
    def solve(self, parameters: Incomplete | None = None, limit: int = 1): ...

class CubicThue(DiophantineEquationType):
    name: str
    def matches(self): ...

class GeneralSumOfEvenPowers(DiophantineEquationType):
    name: str
    def matches(self): ...
    def solve(self, parameters: Incomplete | None = None, limit: int = 1): ...

def diophantine(eq, param=..., syms: Incomplete | None = None, permute: bool = False): ...
def classify_diop(eq, _dict: bool = True): ...
sum_of_powers = power_representation
