from _typeshed import Incomplete
from sympy.core import S as S
from sympy.core.add import Add as Add
from sympy.core.function import count_ops as count_ops
from sympy.core.numbers import Float as Float, oo as oo
from sympy.core.relational import Eq as Eq
from sympy.core.symbol import Dummy as Dummy, Symbol as Symbol, symbols as symbols
from sympy.functions import exp as exp, sqrt as sqrt
from sympy.functions.elementary.complexes import sign as sign
from sympy.integrals.integrals import Integral as Integral
from sympy.polys.domains import ZZ as ZZ
from sympy.polys.polyroots import roots as roots
from sympy.polys.polytools import Poly as Poly
from sympy.solvers.solveset import linsolve as linsolve

def riccati_normal(w, x, b1, b2): ...
def riccati_inverse_normal(y, x, b1, b2, bp: Incomplete | None = None): ...
def riccati_reduced(eq, f, x): ...
def linsolve_dict(eq, syms): ...
def match_riccati(eq, f, x): ...
def val_at_inf(num, den, x): ...
def check_necessary_conds(val_inf, muls): ...
def inverse_transform_poly(num, den, x): ...
def limit_at_inf(num, den, x): ...
def construct_c_case_1(num, den, x, pole): ...
def construct_c_case_2(num, den, x, pole, mul): ...
def construct_c_case_3(): ...
def construct_c(num, den, x, poles, muls): ...
def construct_d_case_4(ser, N): ...
def construct_d_case_5(ser): ...
def construct_d_case_6(num, den, x): ...
def construct_d(num, den, x, val_inf): ...
def rational_laurent_series(num, den, x, r, m, n): ...
def compute_m_ybar(x, poles, choice, N): ...
def solve_aux_eq(numa, dena, numy, deny, x, m): ...
def remove_redundant_sols(sol1, sol2, x): ...
def get_gen_sol_from_part_sol(part_sols, a, x): ...
def solve_riccati(fx, x, b0, b1, b2, gensol: bool = False): ...
