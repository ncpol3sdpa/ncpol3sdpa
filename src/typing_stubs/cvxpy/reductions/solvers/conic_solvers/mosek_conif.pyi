import numpy as np
import scipy as sp
from _typeshed import Incomplete
from cvxpy.constraints import ExpCone as ExpCone, PSD as PSD, PowCone3D as PowCone3D, SOC as SOC
from cvxpy.reductions.cone2cone.affine2direct import Dualize as Dualize, Slacks as Slacks
from cvxpy.reductions.solution import Solution as Solution
from cvxpy.reductions.solvers.conic_solvers.conic_solver import ConicSolver as ConicSolver
from cvxpy.reductions.solvers.utilities import expcone_permutor as expcone_permutor

__MSK_ENUM_PARAM_DEPRECATION__: str

def vectorized_lower_tri_to_mat(v, dim): ...
def vectorized_lower_tri_to_triples(A: sp.sparse.coo_matrix | list[float] | np.ndarray, dim: int) -> tuple[list[int], list[int], list[float]]: ...

class MOSEK(ConicSolver):
    MIP_CAPABLE: bool
    SUPPORTED_CONSTRAINTS: Incomplete
    EXP_CONE_ORDER: Incomplete
    DUAL_EXP_CONE_ORDER: Incomplete
    MI_SUPPORTED_CONSTRAINTS: Incomplete
    def import_solver(self) -> None: ...
    def name(self): ...
    def accepts(self, problem) -> bool: ...
    @staticmethod
    def psd_format_mat(constr): ...
    @staticmethod
    def bar_data(A_psd, c_psd, K): ...
    def apply(self, problem): ...
    def solve_via_data(self, data, warm_start: bool, verbose: bool, solver_opts, solver_cache: Incomplete | None = None): ...
    def invert(self, solver_output, inverse_data): ...
    @staticmethod
    def recover_dual_variables(task, sol): ...
    @staticmethod
    def recover_primal_variables(task, sol, K_dir): ...
    @staticmethod
    def handle_options(task, verbose: bool, solver_opts: dict) -> dict: ...
    @staticmethod
    def is_param(param: str | iparam | dparam | sparam) -> bool: ...
    @staticmethod
    def parse_eps_keyword(solver_opts: dict) -> dict: ...
    @staticmethod
    def tolerance_params() -> tuple[str]: ...
