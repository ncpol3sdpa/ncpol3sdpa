import cvxpy.utilities as u
from _typeshed import Incomplete
from cvxpy import Constant as Constant, error as error
from cvxpy.atoms.atom import Atom as Atom
from cvxpy.constraints import Equality as Equality, Inequality as Inequality, NonNeg as NonNeg, NonPos as NonPos, Zero as Zero
from cvxpy.constraints.constraint import Constraint as Constraint
from cvxpy.error import DPPError as DPPError
from cvxpy.expressions import cvxtypes as cvxtypes
from cvxpy.expressions.variable import Variable as Variable
from cvxpy.interface.matrix_utilities import scalar_value as scalar_value
from cvxpy.problems.objective import Maximize as Maximize, Minimize as Minimize
from cvxpy.reductions import InverseData as InverseData
from cvxpy.reductions.chain import Chain as Chain
from cvxpy.reductions.dgp2dcp.dgp2dcp import Dgp2Dcp as Dgp2Dcp
from cvxpy.reductions.dqcp2dcp import dqcp2dcp as dqcp2dcp
from cvxpy.reductions.eval_params import EvalParams as EvalParams
from cvxpy.reductions.flip_objective import FlipObjective as FlipObjective
from cvxpy.reductions.solution import INF_OR_UNB_MESSAGE as INF_OR_UNB_MESSAGE
from cvxpy.reductions.solvers import bisection as bisection
from cvxpy.reductions.solvers.conic_solvers.conic_solver import ConicSolver as ConicSolver
from cvxpy.reductions.solvers.defines import SOLVER_MAP_CONIC as SOLVER_MAP_CONIC, SOLVER_MAP_QP as SOLVER_MAP_QP
from cvxpy.reductions.solvers.qp_solvers.qp_solver import QpSolver as QpSolver
from cvxpy.reductions.solvers.solver import Solver as Solver
from cvxpy.reductions.solvers.solving_chain import SolvingChain as SolvingChain, construct_solving_chain as construct_solving_chain
from cvxpy.settings import SOLVERS as SOLVERS
from cvxpy.utilities import debug_tools as debug_tools
from cvxpy.utilities.deterministic import unique_list as unique_list
from dataclasses import dataclass
from typing import NamedTuple

class SolveResult(NamedTuple):
    opt_value: Incomplete
    status: Incomplete
    primal_values: Incomplete
    dual_values: Incomplete

class Cache:
    key: Incomplete
    solving_chain: SolvingChain | None
    param_prog: Incomplete
    inverse_data: InverseData | None
    def __init__(self) -> None: ...
    def invalidate(self) -> None: ...
    def make_key(self, solver, gp, ignore_dpp, use_quad_obj): ...
    def gp(self): ...

class Problem(u.Canonical):
    REGISTERED_SOLVE_METHODS: Incomplete
    args: Incomplete
    ndim: int
    def __init__(self, objective: Minimize | Maximize, constraints: list[Constraint] | None = None) -> None: ...
    @property
    def value(self): ...
    @property
    def status(self) -> str: ...
    @property
    def solution(self): ...
    @property
    def objective(self) -> Minimize | Maximize: ...
    @property
    def constraints(self) -> list[Constraint]: ...
    @property
    def param_dict(self): ...
    @property
    def var_dict(self) -> dict[str, Variable]: ...
    def is_dcp(self, dpp: bool = False) -> bool: ...
    def is_dgp(self, dpp: bool = False) -> bool: ...
    def is_dqcp(self) -> bool: ...
    def is_dpp(self, context: str = 'dcp') -> bool: ...
    def is_qp(self) -> bool: ...
    def is_mixed_integer(self) -> bool: ...
    def variables(self) -> list[Variable]: ...
    def parameters(self): ...
    def constants(self) -> list[Constant]: ...
    def atoms(self) -> list[Atom]: ...
    @property
    def size_metrics(self) -> SizeMetrics: ...
    @property
    def solver_stats(self) -> SolverStats: ...
    @property
    def compilation_time(self) -> float | None: ...
    def solve(self, *args, **kwargs) -> None: ...
    @classmethod
    def register_solve(cls, name: str, func) -> None: ...
    def get_problem_data(self, solver, gp: bool = False, enforce_dpp: bool = False, ignore_dpp: bool = False, verbose: bool = False, canon_backend: str | None = None, solver_opts: dict | None = None): ...
    def backward(self) -> None: ...
    def derivative(self) -> None: ...
    def unpack(self, solution) -> None: ...
    def unpack_results(self, solution, chain: SolvingChain, inverse_data) -> None: ...
    def __neg__(self) -> Problem: ...
    def __add__(self, other) -> Problem: ...
    def __radd__(self, other) -> Problem: ...
    def __sub__(self, other) -> Problem: ...
    def __rsub__(self, other) -> Problem: ...
    def __mul__(self, other) -> Problem: ...
    __rmul__ = __mul__
    def __div__(self, other) -> Problem: ...
    def is_constant(self) -> bool: ...
    __truediv__ = __div__

@dataclass
class SolverStats:
    solver_name: str
    solve_time: float | None = ...
    setup_time: float | None = ...
    num_iters: int | None = ...
    extra_stats: dict | None = ...
    @classmethod
    def from_dict(cls, attr: dict, solver_name: str) -> SolverStats: ...

class SizeMetrics:
    num_scalar_variables: int
    max_data_dimension: int
    num_scalar_data: int
    max_big_small_squared: int
    num_scalar_eq_constr: int
    num_scalar_leq_constr: int
    def __init__(self, problem: Problem) -> None: ...
