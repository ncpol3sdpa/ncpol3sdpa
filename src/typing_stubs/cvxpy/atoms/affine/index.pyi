import cvxpy.lin_ops.lin_op as lo
import scipy.sparse as sp
from _typeshed import Incomplete
from cvxpy.atoms.affine.affine_atom import AffAtom as AffAtom
from cvxpy.atoms.affine.reshape import reshape as reshape
from cvxpy.atoms.affine.vec import vec as vec
from cvxpy.constraints.constraint import Constraint as Constraint
from cvxpy.expressions.expression import Expression as Expression

class index(AffAtom):
    key: Incomplete
    def __init__(self, expr, key, orig_key: Incomplete | None = None) -> None: ...
    def is_atom_log_log_convex(self) -> bool: ...
    def is_atom_log_log_concave(self) -> bool: ...
    def name(self): ...
    def numeric(self, values): ...
    def shape_from_args(self) -> tuple[int, ...]: ...
    def get_data(self) -> list: ...
    def graph_implementation(self, arg_objs, shape: tuple[int, ...], data: Incomplete | None = None) -> tuple[lo.LinOp, list[Constraint]]: ...

class special_index(AffAtom):
    key: Incomplete
    def __init__(self, expr: Expression, key) -> None: ...
    def is_atom_log_log_convex(self) -> bool: ...
    def is_atom_log_log_concave(self) -> bool: ...
    def name(self) -> str: ...
    def numeric(self, values): ...
    def shape_from_args(self) -> tuple[int, ...]: ...
    def get_data(self) -> list: ...
    @property
    def grad(self) -> list[sp.csc_matrix] | None: ...
    def graph_implementation(self, arg_objs: list, shape: tuple[int, ...], data: Incomplete | None = None) -> tuple[lo.LinOp, list[Constraint]]: ...
