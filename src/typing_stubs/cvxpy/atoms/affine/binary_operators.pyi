import abc
import cvxpy.lin_ops.lin_op as lo
from _typeshed import Incomplete
from cvxpy.atoms.affine.add_expr import AddExpression as AddExpression
from cvxpy.atoms.affine.affine_atom import AffAtom as AffAtom
from cvxpy.atoms.affine.conj import conj as conj
from cvxpy.atoms.affine.reshape import deep_flatten as deep_flatten, reshape as reshape
from cvxpy.constraints.constraint import Constraint as Constraint
from cvxpy.error import DCPError as DCPError
from cvxpy.expressions.constants.parameter import is_param_affine as is_param_affine, is_param_free as is_param_free
from cvxpy.expressions.expression import Expression as Expression

class BinaryOperator(AffAtom, metaclass=abc.ABCMeta):
    OP_NAME: str
    def __init__(self, lh_exp, rh_exp) -> None: ...
    def name(self): ...
    def numeric(self, values): ...
    def sign_from_args(self) -> tuple[bool, bool]: ...
    def is_imag(self) -> bool: ...
    def is_complex(self) -> bool: ...

def matmul(lh_exp, rh_exp) -> MulExpression: ...

class MulExpression(BinaryOperator):
    OP_NAME: str
    OP_FUNC: Incomplete
    def numeric(self, values): ...
    def shape_from_args(self) -> tuple[int, ...]: ...
    def is_atom_convex(self) -> bool: ...
    def is_atom_concave(self) -> bool: ...
    def is_atom_log_log_convex(self) -> bool: ...
    def is_atom_log_log_concave(self) -> bool: ...
    def is_incr(self, idx) -> bool: ...
    def is_decr(self, idx) -> bool: ...
    def graph_implementation(self, arg_objs, shape: tuple[int, ...], data: Incomplete | None = None) -> tuple[lo.LinOp, list[Constraint]]: ...

class multiply(MulExpression):
    def __init__(self, lh_expr, rh_expr) -> None: ...
    def is_atom_log_log_convex(self) -> bool: ...
    def is_atom_log_log_concave(self) -> bool: ...
    def is_atom_quasiconvex(self) -> bool: ...
    def is_atom_quasiconcave(self) -> bool: ...
    def numeric(self, values): ...
    def validate_arguments(self) -> None: ...
    def shape_from_args(self) -> tuple[int, ...]: ...
    def is_psd(self) -> bool: ...
    def is_nsd(self) -> bool: ...
    def graph_implementation(self, arg_objs, shape: tuple[int, ...], data: Incomplete | None = None) -> tuple[lo.LinOp, list[Constraint]]: ...

class DivExpression(BinaryOperator):
    OP_NAME: str
    OP_FUNC: Incomplete
    def __init__(self, lh_expr, rh_expr) -> None: ...
    def numeric(self, values): ...
    def is_quadratic(self) -> bool: ...
    def has_quadratic_term(self) -> bool: ...
    def is_qpwa(self) -> bool: ...
    def shape_from_args(self) -> tuple[int, ...]: ...
    def is_atom_convex(self) -> bool: ...
    def is_atom_concave(self) -> bool: ...
    def is_atom_log_log_convex(self) -> bool: ...
    def is_atom_log_log_concave(self) -> bool: ...
    def is_atom_quasiconvex(self) -> bool: ...
    def is_atom_quasiconcave(self) -> bool: ...
    def is_incr(self, idx) -> bool: ...
    def is_decr(self, idx) -> bool: ...
    def graph_implementation(self, arg_objs, shape: tuple[int, ...], data: Incomplete | None = None) -> tuple[lo.LinOp, list[Constraint]]: ...

def vdot(x, y): ...
def scalar_product(x, y): ...
def outer(x, y): ...
