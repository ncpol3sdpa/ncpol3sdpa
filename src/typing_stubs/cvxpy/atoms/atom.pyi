import abc
import cvxpy.lin_ops.lin_op as lo
from _typeshed import Incomplete
from cvxpy.constraints.constraint import Constraint as Constraint
from cvxpy.expressions import cvxtypes as cvxtypes
from cvxpy.expressions.constants import Constant as Constant
from cvxpy.expressions.expression import Expression as Expression
from cvxpy.utilities.deterministic import unique_list as unique_list

class Atom(Expression, metaclass=abc.ABCMeta):
    id: Incomplete
    args: Incomplete
    def __init__(self, *args) -> None: ...
    def name(self) -> str: ...
    def validate_arguments(self) -> None: ...
    @abc.abstractmethod
    def shape_from_args(self) -> tuple[int, ...]: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @abc.abstractmethod
    def sign_from_args(self) -> tuple[bool, bool]: ...
    def is_nonneg(self) -> bool: ...
    def is_nonpos(self) -> bool: ...
    def is_imag(self) -> bool: ...
    def is_complex(self) -> bool: ...
    @abc.abstractmethod
    def is_atom_convex(self) -> bool: ...
    @abc.abstractmethod
    def is_atom_concave(self) -> bool: ...
    def is_atom_affine(self) -> bool: ...
    def is_atom_log_log_convex(self) -> bool: ...
    def is_atom_log_log_concave(self) -> bool: ...
    def is_atom_quasiconvex(self) -> bool: ...
    def is_atom_quasiconcave(self) -> bool: ...
    def is_atom_log_log_affine(self) -> bool: ...
    @abc.abstractmethod
    def is_incr(self, idx) -> bool: ...
    @abc.abstractmethod
    def is_decr(self, idx) -> bool: ...
    def is_convex(self) -> bool: ...
    def is_concave(self) -> bool: ...
    def is_dpp(self, context: str = 'dcp') -> bool: ...
    def is_log_log_convex(self) -> bool: ...
    def is_log_log_concave(self) -> bool: ...
    def is_quasiconvex(self) -> bool: ...
    def is_quasiconcave(self) -> bool: ...
    def canonicalize(self): ...
    def graph_implementation(self, arg_objs, shape: tuple[int, ...], data: Incomplete | None = None) -> tuple[lo.LinOp, list['Constraint']]: ...
    @property
    def value(self): ...
    @property
    def grad(self): ...
    @property
    def domain(self) -> list['Constraint']: ...
    @staticmethod
    def numpy_numeric(numeric_func): ...
    def atoms(self) -> list['Atom']: ...
