import abc
import cvxpy.utilities as u
import numpy as np
from _typeshed import Incomplete
from cvxpy import error as error
from cvxpy.constraints import Equality as Equality, Inequality as Inequality, PSD as PSD
from cvxpy.expressions import cvxtypes as cvxtypes
from cvxpy.utilities import scopes as scopes
from cvxpy.utilities.shape import size_from_shape as size_from_shape
from typing import Literal

__STAR_MATMUL_COUNT__: int
__STAR_MATMUL_WARNING__: str
__NUMPY_UFUNC_ERROR__: str
__INPLACE_MUTATION_ERROR__: str
__ABS_ERROR__: str
DEFAULT_ORDER_DEPRECATION_MSG: str
__BINARY_EXPRESSION_UFUNCS__: Incomplete
ExpressionLike: str

class Expression(u.Canonical, metaclass=abc.ABCMeta):
    __array_priority__: int
    @property
    @abc.abstractmethod
    def value(self) -> np.ndarray | None: ...
    @property
    @abc.abstractmethod
    def grad(self): ...
    @property
    @abc.abstractmethod
    def domain(self): ...
    @abc.abstractmethod
    def name(self) -> str: ...
    @property
    def expr(self): ...
    @property
    def curvatures(self) -> list[str]: ...
    @property
    def curvature(self) -> str: ...
    @property
    def log_log_curvature(self) -> str: ...
    def is_constant(self) -> bool: ...
    def is_affine(self) -> bool: ...
    @abc.abstractmethod
    def is_convex(self) -> bool: ...
    @abc.abstractmethod
    def is_concave(self) -> bool: ...
    def is_dcp(self, dpp: bool = False) -> bool: ...
    def is_log_log_constant(self) -> bool: ...
    def is_log_log_affine(self) -> bool: ...
    @abc.abstractmethod
    def is_log_log_convex(self) -> bool: ...
    @abc.abstractmethod
    def is_log_log_concave(self) -> bool: ...
    def is_dgp(self, dpp: bool = False) -> bool: ...
    @abc.abstractmethod
    def is_dpp(self, context: str = 'dcp') -> bool: ...
    def is_quasiconvex(self) -> bool: ...
    def is_quasiconcave(self) -> bool: ...
    def is_quasilinear(self) -> bool: ...
    def is_dqcp(self) -> bool: ...
    def is_hermitian(self) -> bool: ...
    def is_psd(self) -> bool: ...
    def is_nsd(self) -> bool: ...
    def is_quadratic(self) -> bool: ...
    def has_quadratic_term(self) -> bool: ...
    def is_symmetric(self) -> bool: ...
    def is_skew_symmetric(self) -> bool: ...
    def is_pwl(self) -> bool: ...
    def is_qpwa(self) -> bool: ...
    @property
    def sign(self) -> str: ...
    def is_zero(self) -> bool: ...
    @abc.abstractmethod
    def is_nonneg(self) -> bool: ...
    @abc.abstractmethod
    def is_nonpos(self) -> bool: ...
    @property
    @abc.abstractmethod
    def shape(self) -> tuple[int, ...]: ...
    def is_real(self) -> bool: ...
    @property
    @abc.abstractmethod
    def is_imag(self) -> bool: ...
    @abc.abstractmethod
    def is_complex(self) -> bool: ...
    @property
    def size(self) -> int: ...
    @property
    def ndim(self) -> int: ...
    def flatten(self, order: Literal['F', 'C', None] = None): ...
    def is_scalar(self) -> bool: ...
    def is_vector(self) -> bool: ...
    def is_matrix(self) -> bool: ...
    def __getitem__(self, key) -> Expression: ...
    @property
    def T(self) -> Expression: ...
    @property
    def H(self) -> Expression: ...
    def __pow__(self, power: float) -> Expression: ...
    def __rpow__(self, base: float) -> Expression: ...
    @staticmethod
    def cast_to_const(expr: Expression): ...
    @staticmethod
    def broadcast(lh_expr: Expression, rh_expr: Expression): ...
    def __add__(self, other: ExpressionLike) -> Expression: ...
    def __radd__(self, other: ExpressionLike) -> Expression: ...
    def __sub__(self, other: ExpressionLike) -> Expression: ...
    def __rsub__(self, other: ExpressionLike) -> Expression: ...
    def __mul__(self, other: ExpressionLike) -> Expression: ...
    def __matmul__(self, other: ExpressionLike) -> Expression: ...
    def __truediv__(self, other: ExpressionLike) -> Expression: ...
    def __div__(self, other: ExpressionLike) -> Expression: ...
    def __rdiv__(self, other: ExpressionLike) -> Expression: ...
    def __rtruediv__(self, other: ExpressionLike) -> Expression: ...
    def __rmul__(self, other: ExpressionLike) -> Expression: ...
    def __rmatmul__(self, other: ExpressionLike) -> Expression: ...
    def __neg__(self) -> Expression: ...
    def __rshift__(self, other: ExpressionLike) -> PSD: ...
    def __rrshift__(self, other: ExpressionLike) -> PSD: ...
    def __lshift__(self, other: ExpressionLike) -> PSD: ...
    def __rlshift__(self, other: ExpressionLike) -> PSD: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: ExpressionLike) -> Equality: ...
    def __le__(self, other: ExpressionLike) -> Inequality: ...
    def __lt__(self, other: ExpressionLike): ...
    def __ge__(self, other: ExpressionLike) -> Inequality: ...
    def __gt__(self, other: ExpressionLike): ...
    def __array_ufunc__(self, ufunc, method, *args, **kwargs): ...
    def __abs__(self) -> None: ...
    def conj(self) -> Expression: ...
    def conjugate(self) -> Expression: ...
    def cumsum(self, axis: int = 0) -> Expression: ...
    def max(self, axis: Incomplete | None = None, *, keepdims: bool = False) -> Expression: ...
    def mean(self, axis: Incomplete | None = None, *, keepdims: bool = False) -> Expression: ...
    def min(self, axis: Incomplete | None = None, *, keepdims: bool = False) -> Expression: ...
    def prod(self, axis: Incomplete | None = None, *, keepdims: bool = False) -> Expression: ...
    def ptp(self, axis: Incomplete | None = None, *, keepdims: bool = False) -> Expression: ...
    def reshape(self, shape, order: Literal['F', 'C', None] = None) -> Expression: ...
    def std(self, axis: Incomplete | None = None, *, ddof: int = 0, keepdims: bool = False) -> Expression: ...
    def sum(self, axis: Incomplete | None = None, *, keepdims: bool = False) -> Expression: ...
    def trace(self) -> Expression: ...
    def var(self, *, ddof: int = 0) -> Expression: ...
