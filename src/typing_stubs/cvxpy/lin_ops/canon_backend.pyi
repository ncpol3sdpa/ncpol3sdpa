import abc
import numpy as np
import scipy.sparse as sp
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from cvxpy.lin_ops import LinOp as LinOp
from cvxpy.settings import NUMPY_CANON_BACKEND as NUMPY_CANON_BACKEND, RUST_CANON_BACKEND as RUST_CANON_BACKEND, SCIPY_CANON_BACKEND as SCIPY_CANON_BACKEND
from dataclasses import dataclass
from enum import Enum
from typing import Any, Callable

class Constant(Enum):
    ID = -1

@dataclass
class TensorRepresentation:
    data: np.ndarray
    row: np.ndarray
    col: np.ndarray
    parameter_offset: np.ndarray
    shape: tuple[int, int]
    def __post_init__(self) -> None: ...
    @classmethod
    def combine(cls, tensors: list[TensorRepresentation]) -> TensorRepresentation: ...
    def __eq__(self, other: TensorRepresentation) -> bool: ...
    def __add__(self, other: TensorRepresentation) -> TensorRepresentation: ...
    @classmethod
    def empty_with_shape(cls, shape: tuple[int, int]) -> TensorRepresentation: ...
    def flatten_tensor(self, num_param_slices: int) -> sp.csc_matrix: ...
    def get_param_slice(self, param_offset: int) -> sp.csc_matrix: ...

class CanonBackend(ABC, metaclass=abc.ABCMeta):
    param_size_plus_one: Incomplete
    id_to_col: Incomplete
    param_to_size: Incomplete
    param_to_col: Incomplete
    var_length: Incomplete
    def __init__(self, id_to_col: dict[int, int], param_to_size: dict[int, int], param_to_col: dict[int, int], param_size_plus_one: int, var_length: int) -> None: ...
    @classmethod
    def get_backend(cls, backend_name: str, *args, **kwargs) -> CanonBackend: ...
    @abstractmethod
    def build_matrix(self, lin_ops: list[LinOp]) -> sp.csc_matrix: ...

class PythonCanonBackend(CanonBackend, metaclass=abc.ABCMeta):
    def build_matrix(self, lin_ops: list[LinOp]) -> sp.csc_matrix: ...
    def process_constraint(self, lin_op: LinOp, empty_view: TensorView) -> TensorView: ...
    def get_constant_data(self, lin_op: LinOp, view: TensorView, column: bool) -> tuple[np.ndarray | sp.spmatrix, bool]: ...
    @staticmethod
    @abstractmethod
    def get_constant_data_from_const(lin_op: LinOp) -> np.ndarray | sp.spmatrix: ...
    @staticmethod
    @abstractmethod
    def reshape_constant_data(constant_data: Any, lin_op_shape: tuple[int, int]) -> Any: ...
    @staticmethod
    def concatenate_tensors(tensors: list[TensorRepresentation]) -> TensorRepresentation: ...
    @abstractmethod
    def get_empty_view(self) -> TensorView: ...
    def get_func(self, func_name: str) -> Callable: ...
    @staticmethod
    def sum_op(_lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    def reshape(_lin: LinOp, view: TensorView) -> TensorView: ...
    @abstractmethod
    def mul(self, lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    @abstractmethod
    def promote(lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    @abstractmethod
    def broadcast_to(lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    def neg(_lin: LinOp, view: TensorView) -> TensorView: ...
    @abstractmethod
    def mul_elem(self, lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    @abstractmethod
    def sum_entries(_lin: LinOp, view: TensorView) -> TensorView: ...
    @abstractmethod
    def div(self, lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    def index(lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    @abstractmethod
    def diag_vec(lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    @abstractmethod
    def get_stack_func(total_rows: int, offset: int) -> Callable: ...
    def hstack(self, lin: LinOp, view: TensorView) -> TensorView: ...
    def concatenate(self, lin: LinOp, view: TensorView) -> TensorView: ...
    def vstack(self, lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    def transpose(lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    def upper_tri(lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    def diag_mat(lin: LinOp, view: TensorView) -> TensorView: ...
    @abstractmethod
    def rmul(self, lin: LinOp, view: TensorView) -> TensorView: ...
    @staticmethod
    @abstractmethod
    def trace(lin: LinOp, view: TensorView) -> TensorView: ...
    @abstractmethod
    def conv(self, lin: LinOp, view: TensorView) -> TensorView: ...
    @abstractmethod
    def kron_r(self, lin: LinOp, view: TensorView) -> TensorView: ...
    @abstractmethod
    def kron_l(self, lin: LinOp, view: TensorView) -> TensorView: ...
    @abstractmethod
    def get_variable_tensor(self, shape: tuple[int, ...], variable_id: int) -> Any: ...
    @abstractmethod
    def get_data_tensor(self, data: Any) -> Any: ...
    @abstractmethod
    def get_param_tensor(self, shape: tuple[int, ...], parameter_id: int) -> Any: ...

class RustCanonBackend(CanonBackend):
    def build_matrix(self, lin_ops: list[LinOp]) -> sp.csc_matrix: ...

class NumPyCanonBackend(PythonCanonBackend):
    @staticmethod
    def get_constant_data_from_const(lin_op: LinOp) -> np.ndarray: ...
    @staticmethod
    def reshape_constant_data(constant_data: dict[int, np.ndarray], lin_op_shape: tuple[int, int]) -> dict[int, np.ndarray]: ...
    def concatenate_tensors(self, tensors: list[TensorRepresentation]) -> TensorRepresentation: ...
    def get_empty_view(self) -> NumPyTensorView: ...
    def mul(self, lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    @staticmethod
    def promote(lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    @staticmethod
    def broadcast_to(lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    def mul_elem(self, lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    @staticmethod
    def sum_entries(_lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    def div(self, lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    @staticmethod
    def diag_vec(lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    @staticmethod
    def get_stack_func(total_rows: int, offset: int) -> Callable: ...
    def rmul(self, lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    @staticmethod
    def trace(lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    def conv(self, lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    def kron_r(self, lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    def kron_l(self, lin: LinOp, view: NumPyTensorView) -> NumPyTensorView: ...
    def get_variable_tensor(self, shape: tuple[int, ...], variable_id: int) -> dict[int, dict[int, np.ndarray]]: ...
    def get_data_tensor(self, data: np.ndarray) -> dict[int, dict[int, np.ndarray]]: ...
    def get_param_tensor(self, shape: tuple[int, ...], parameter_id: int) -> dict[int, dict[int, np.ndarray]]: ...

class SciPyCanonBackend(PythonCanonBackend):
    @staticmethod
    def get_constant_data_from_const(lin_op: LinOp) -> sp.csr_matrix: ...
    @staticmethod
    def reshape_constant_data(constant_data: dict[int, sp.csc_matrix], lin_op_shape: tuple[int, int]) -> dict[int, sp.csc_matrix]: ...
    def get_empty_view(self) -> SciPyTensorView: ...
    @staticmethod
    def neg(_lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    def mul(self, lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    @staticmethod
    def promote(lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    @staticmethod
    def broadcast_to(lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    def mul_elem(self, lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    def sum_entries(self, _lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    def div(self, lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    @staticmethod
    def diag_vec(lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    @staticmethod
    def get_stack_func(total_rows: int, offset: int) -> Callable: ...
    def rmul(self, lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    @staticmethod
    def trace(lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    def conv(self, lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    def kron_r(self, lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    def kron_l(self, lin: LinOp, view: SciPyTensorView) -> SciPyTensorView: ...
    def get_variable_tensor(self, shape: tuple[int, ...], variable_id: int) -> dict[int, dict[int, sp.csc_matrix]]: ...
    def get_data_tensor(self, data: np.ndarray | sp.spmatrix) -> dict[int, dict[int, sp.csr_matrix]]: ...
    def get_param_tensor(self, shape: tuple[int, ...], parameter_id: int) -> dict[int, dict[int, sp.csc_matrix]]: ...

class TensorView(ABC, metaclass=abc.ABCMeta):
    variable_ids: Incomplete
    tensor: Incomplete
    is_parameter_free: Incomplete
    param_size_plus_one: Incomplete
    id_to_col: Incomplete
    param_to_size: Incomplete
    param_to_col: Incomplete
    var_length: Incomplete
    def __init__(self, variable_ids: set[int] | None, tensor: Any, is_parameter_free: bool, param_size_plus_one: int, id_to_col: dict[int, int], param_to_size: dict[int, int], param_to_col: dict[int, int], var_length: int) -> None: ...
    def __iadd__(self, other: TensorView) -> TensorView: ...
    @staticmethod
    @abstractmethod
    def combine_potentially_none(a: Any | None, b: Any | None) -> Any | None: ...
    @classmethod
    def get_empty_view(cls, param_size_plus_one: int, id_to_col: dict[int, int], param_to_size: dict[int, int], param_to_col: dict[int, int], var_length: int) -> TensorView: ...
    @staticmethod
    def is_constant_data(variable_ids: set[int]) -> bool: ...
    @property
    @abstractmethod
    def rows(self) -> int: ...
    @abstractmethod
    def get_tensor_representation(self, row_offset: int, total_rows: int) -> TensorRepresentation: ...
    @abstractmethod
    def select_rows(self, rows: np.ndarray) -> None: ...
    @abstractmethod
    def apply_all(self, func: Callable) -> None: ...
    @abstractmethod
    def create_new_tensor_view(self, variable_ids: set[int], tensor: Any, is_parameter_free: bool) -> TensorView: ...

class DictTensorView(TensorView, ABC, metaclass=abc.ABCMeta):
    is_parameter_free: Incomplete
    def accumulate_over_variables(self, func: Callable, is_param_free_function: bool) -> TensorView: ...
    def combine_potentially_none(self, a: dict | None, b: dict | None) -> dict | None: ...
    @staticmethod
    @abstractmethod
    def add_tensors(a: Any, b: Any) -> Any: ...
    @staticmethod
    @abstractmethod
    def tensor_type(): ...
    def add_dicts(self, a: dict, b: dict) -> dict: ...

class NumPyTensorView(DictTensorView):
    @property
    def rows(self) -> int: ...
    def get_tensor_representation(self, row_offset: int, total_rows: int) -> TensorRepresentation: ...
    def select_rows(self, rows: np.ndarray) -> None: ...
    tensor: Incomplete
    def apply_all(self, func: Callable) -> None: ...
    def create_new_tensor_view(self, variable_ids: set[int], tensor: Any, is_parameter_free: bool) -> NumPyTensorView: ...
    @staticmethod
    def apply_to_parameters(func: Callable, parameter_representation: dict[int, np.ndarray]) -> dict[int, np.ndarray]: ...
    @staticmethod
    def add_tensors(a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    @staticmethod
    def tensor_type(): ...

class SciPyTensorView(DictTensorView):
    @property
    def rows(self) -> int: ...
    def get_tensor_representation(self, row_offset: int, total_rows: int) -> TensorRepresentation: ...
    def select_rows(self, rows: np.ndarray) -> None: ...
    tensor: Incomplete
    def apply_all(self, func: Callable) -> None: ...
    def create_new_tensor_view(self, variable_ids: set[int], tensor: Any, is_parameter_free: bool) -> SciPyTensorView: ...
    def apply_to_parameters(self, func: Callable, parameter_representation: dict[int, sp.spmatrix]) -> dict[int, sp.spmatrix]: ...
    @staticmethod
    def add_tensors(a: sp.spmatrix, b: sp.spmatrix) -> sp.spmatrix: ...
    @staticmethod
    def tensor_type(): ...
